// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// Indicates who should participate in performing the action described.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ActivityDefinitionParticipant>))]
  public class ActivityDefinitionParticipant : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Indicates how the actor will be involved in the action - author, reviewer, witness, etc.
    /// </summary>
    public CodeableConcept Function { get; set; }
    /// <summary>
    /// The role the participant should play in performing the described action.
    /// </summary>
    public CodeableConcept Role { get; set; }
    /// <summary>
    /// The type of participant in the action.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// When this element is a reference, it SHOULD be a reference to a definitional resource (for example, a location type, rather than a specific location).
    /// </summary>
    public Reference TypeReference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      if (TypeReference != null)
      {
        writer.WritePropertyName("typeReference");
        TypeReference.SerializeJson(writer, options);
      }

      if (Role != null)
      {
        writer.WritePropertyName("role");
        Role.SerializeJson(writer, options);
      }

      if (Function != null)
      {
        writer.WritePropertyName("function");
        Function.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "function":
          Function = new fhirCsR5.Models.CodeableConcept();
          Function.DeserializeJson(ref reader, options);
          break;

        case "role":
          Role = new fhirCsR5.Models.CodeableConcept();
          Role.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR5.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        case "typeReference":
          TypeReference = new fhirCsR5.Models.Reference();
          TypeReference.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ActivityDefinition.participant.type field
  /// </summary>
  public static class ActivityDefinitionParticipantTypeCodes {
    public const string CARETEAM = "careteam";
    public const string DEVICE = "device";
    public const string GROUP = "group";
    public const string HEALTHCARESERVICE = "healthcareservice";
    public const string LOCATION = "location";
    public const string ORGANIZATION = "organization";
    public const string PATIENT = "patient";
    public const string PRACTITIONER = "practitioner";
    public const string PRACTITIONERROLE = "practitionerrole";
    public const string RELATEDPERSON = "relatedperson";
    public static HashSet<string> Values = new HashSet<string>() {
      "careteam",
      "device",
      "group",
      "healthcareservice",
      "location",
      "organization",
      "patient",
      "practitioner",
      "practitionerrole",
      "relatedperson",
    };
  }
  /// <summary>
  /// Dynamic values are applied in the order in which they are defined in the ActivityDefinition. Note that if both a transform and dynamic values are specified, the dynamic values will be applied to the result of the transform.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ActivityDefinitionDynamicValue>))]
  public class ActivityDefinitionDynamicValue : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The expression may be inlined, or may be a reference to a named expression within a logic library referenced by the library element.
    /// </summary>
    public Expression Expression { get; set; }
    /// <summary>
    /// The path attribute contains a [Simple FHIRPath Subset](fhirpath.html#simple) that allows path traversal, but not calculation.
    /// </summary>
    public string Path { get; set; }
    /// <summary>
    /// Extension container element for Path
    /// </summary>
    public Element _Path { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Path))
      {
        writer.WriteString("path", (string)Path!);
      }

      if (_Path != null)
      {
        writer.WritePropertyName("_path");
        _Path.SerializeJson(writer, options);
      }

      if (Expression != null)
      {
        writer.WritePropertyName("expression");
        Expression.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "expression":
          Expression = new fhirCsR5.Models.Expression();
          Expression.DeserializeJson(ref reader, options);
          break;

        case "path":
          Path = reader.GetString();
          break;

        case "_path":
          _Path = new fhirCsR5.Models.Element();
          _Path.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ActivityDefinition>))]
  public class ActivityDefinition : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ActivityDefinition";
    /// <summary>
    /// The 'date' element may be more recent than the approval date because of minor changes or editorial corrections.
    /// </summary>
    public string ApprovalDate { get; set; }
    /// <summary>
    /// Extension container element for ApprovalDate
    /// </summary>
    public Element _ApprovalDate { get; set; }
    /// <summary>
    /// An individiual or organization primarily involved in the creation and maintenance of the content.
    /// </summary>
    public List<ContactDetail> Author { get; set; }
    /// <summary>
    /// Only used if not implicit in the code found in ServiceRequest.type.
    /// </summary>
    public List<CodeableConcept> BodySite { get; set; }
    /// <summary>
    /// Tends to be less relevant for activities involving particular products.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    /// </summary>
    public string Copyright { get; set; }
    /// <summary>
    /// Extension container element for Copyright
    /// </summary>
    public Element _Copyright { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the activity definition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// This description can be used to capture details such as why the activity definition was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the activity definition as conveyed in the 'text' field of the resource itself. This item SHOULD be populated unless the information is available from context (e.g. the language of the activity definition is presumed to be the predominant language in the place the activity definition was created).
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// This element is not intended to be used to communicate a decision support response to cancel an order in progress. That should be done with the "remove" type of a PlanDefinition or RequestGroup.
    /// </summary>
    public bool? DoNotPerform { get; set; }
    /// <summary>
    /// Extension container element for DoNotPerform
    /// </summary>
    public Element _DoNotPerform { get; set; }
    /// <summary>
    /// If a dosage instruction is used, the definition should not specify timing or quantity.
    /// </summary>
    public List<Dosage> Dosage { get; set; }
    /// <summary>
    /// Dynamic values are applied in the order in which they are defined in the ActivityDefinition. Note that if both a transform and dynamic values are specified, the dynamic values will be applied to the result of the transform.
    /// </summary>
    public List<ActivityDefinitionDynamicValue> DynamicValue { get; set; }
    /// <summary>
    /// An individual or organization primarily responsible for internal coherence of the content.
    /// </summary>
    public List<ContactDetail> Editor { get; set; }
    /// <summary>
    /// The effective period for a activity definition  determines when the content is applicable for usage and is independent of publication and review dates. For example, a measure intended to be used for the year 2016 might be published in 2015.
    /// </summary>
    public Period EffectivePeriod { get; set; }
    /// <summary>
    /// An individual or organization responsible for officially endorsing the content for use in some setting.
    /// </summary>
    public List<ContactDetail> Endorser { get; set; }
    /// <summary>
    /// Allows filtering of activity definitions that are appropriate for use versus not.
    /// </summary>
    public bool? Experimental { get; set; }
    /// <summary>
    /// Extension container element for Experimental
    /// </summary>
    public Element _Experimental { get; set; }
    /// <summary>
    /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this activity definition outside of FHIR, where it is not possible to use the logical URI.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Indicates the level of authority/intentionality associated with the activity and where the request should fit into the workflow chain.
    /// </summary>
    public string Intent { get; set; }
    /// <summary>
    /// Extension container element for Intent
    /// </summary>
    public Element _Intent { get; set; }
    /// <summary>
    /// It may be possible for the activity definition to be used in jurisdictions other than those for which it was originally designed or intended.
    /// </summary>
    public List<CodeableConcept> Jurisdiction { get; set; }
    /// <summary>
    /// May determine what types of extensions are permitted.
    /// </summary>
    public string Kind { get; set; }
    /// <summary>
    /// Extension container element for Kind
    /// </summary>
    public Element _Kind { get; set; }
    /// <summary>
    /// If specified, this date follows the original approval date.
    /// </summary>
    public string LastReviewDate { get; set; }
    /// <summary>
    /// Extension container element for LastReviewDate
    /// </summary>
    public Element _LastReviewDate { get; set; }
    /// <summary>
    /// A reference to a Library resource containing any formal logic used by the activity definition.
    /// </summary>
    public List<string> Library { get; set; }
    /// <summary>
    /// Extension container element for Library
    /// </summary>
    public List<Element> _Library { get; set; }
    /// <summary>
    /// May reference a specific clinical location or may just identify a type of location.
    /// </summary>
    public CodeableReference Location { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Defines observation requirements for the action to be performed, such as body weight or surface area.
    /// </summary>
    public List<Reference> ObservationRequirement { get; set; }
    /// <summary>
    /// Defines the observations that are expected to be produced by the action.
    /// </summary>
    public List<Reference> ObservationResultRequirement { get; set; }
    /// <summary>
    /// Indicates who should participate in performing the action described.
    /// </summary>
    public List<ActivityDefinitionParticipant> Participant { get; set; }
    /// <summary>
    /// Indicates how quickly the activity  should be addressed with respect to other requests.
    /// </summary>
    public string Priority { get; set; }
    /// <summary>
    /// Extension container element for Priority
    /// </summary>
    public Element _Priority { get; set; }
    /// <summary>
    /// Identifies the food, drug or other product being consumed or supplied in the activity.
    /// </summary>
    public Reference ProductReference { get; set; }
    /// <summary>
    /// Identifies the food, drug or other product being consumed or supplied in the activity.
    /// </summary>
    public CodeableConcept ProductCodeableConcept { get; set; }
    /// <summary>
    /// A profile to which the target of the activity definition is expected to conform.
    /// </summary>
    public string Profile { get; set; }
    /// <summary>
    /// Extension container element for Profile
    /// </summary>
    public Element _Profile { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the activity definition is the organization or individual primarily responsible for the maintenance and upkeep of the activity definition. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the activity definition. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// This element does not describe the usage of the activity definition. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this activity definition.
    /// </summary>
    public string Purpose { get; set; }
    /// <summary>
    /// Extension container element for Purpose
    /// </summary>
    public Element _Purpose { get; set; }
    /// <summary>
    /// Identifies the quantity expected to be consumed at once (per dose, per meal, etc.).
    /// </summary>
    public Quantity Quantity { get; set; }
    /// <summary>
    /// Each related artifact is either an attachment, or a reference to another resource, but not both.
    /// </summary>
    public List<RelatedArtifact> RelatedArtifact { get; set; }
    /// <summary>
    /// An individual or organization primarily responsible for review of some aspect of the content.
    /// </summary>
    public List<ContactDetail> Reviewer { get; set; }
    /// <summary>
    /// Defines specimen requirements for the action to be performed, such as required specimens for a lab test.
    /// </summary>
    public List<Reference> SpecimenRequirement { get; set; }
    /// <summary>
    /// Allows filtering of activity definitions that are appropriate for use versus not.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    /// </summary>
    public CodeableConcept SubjectCodeableConcept { get; set; }
    /// <summary>
    /// A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    /// </summary>
    public Reference SubjectReference { get; set; }
    /// <summary>
    /// A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    /// </summary>
    public string SubjectCanonical { get; set; }
    /// <summary>
    /// Extension container element for SubjectCanonical
    /// </summary>
    public Element _SubjectCanonical { get; set; }
    /// <summary>
    /// An explanatory or alternate title for the activity definition giving additional information about its content.
    /// </summary>
    public string Subtitle { get; set; }
    /// <summary>
    /// Extension container element for Subtitle
    /// </summary>
    public Element _Subtitle { get; set; }
    /// <summary>
    /// The intent of the timing element is to provide timing when the action should be performed. As a definitional resource, this timing is interpreted as part of an apply operation so that the timing of the result actions in a CarePlan or RequestGroup, for example, would be specified by evaluating the timing definition in the context of the apply and setting the resulting timing on the appropriate elements of the target resource. If the timing is an Age, the activity is expected to be performed when the subject is the given Age. When the timing is a Duration, the activity is expected to be performed within the specified duration from the apply. When the timing is a Range, it may be a range of Ages or Durations, providing a range for the expected timing of the resulting activity. When the timing is a Timing, it is establishing a schedule for the timing of the resulting activity.
    /// </summary>
    public Timing TimingTiming { get; set; }
    /// <summary>
    /// The intent of the timing element is to provide timing when the action should be performed. As a definitional resource, this timing is interpreted as part of an apply operation so that the timing of the result actions in a CarePlan or RequestGroup, for example, would be specified by evaluating the timing definition in the context of the apply and setting the resulting timing on the appropriate elements of the target resource. If the timing is an Age, the activity is expected to be performed when the subject is the given Age. When the timing is a Duration, the activity is expected to be performed within the specified duration from the apply. When the timing is a Range, it may be a range of Ages or Durations, providing a range for the expected timing of the resulting activity. When the timing is a Timing, it is establishing a schedule for the timing of the resulting activity.
    /// </summary>
    public Age TimingAge { get; set; }
    /// <summary>
    /// The intent of the timing element is to provide timing when the action should be performed. As a definitional resource, this timing is interpreted as part of an apply operation so that the timing of the result actions in a CarePlan or RequestGroup, for example, would be specified by evaluating the timing definition in the context of the apply and setting the resulting timing on the appropriate elements of the target resource. If the timing is an Age, the activity is expected to be performed when the subject is the given Age. When the timing is a Duration, the activity is expected to be performed within the specified duration from the apply. When the timing is a Range, it may be a range of Ages or Durations, providing a range for the expected timing of the resulting activity. When the timing is a Timing, it is establishing a schedule for the timing of the resulting activity.
    /// </summary>
    public Range TimingRange { get; set; }
    /// <summary>
    /// The intent of the timing element is to provide timing when the action should be performed. As a definitional resource, this timing is interpreted as part of an apply operation so that the timing of the result actions in a CarePlan or RequestGroup, for example, would be specified by evaluating the timing definition in the context of the apply and setting the resulting timing on the appropriate elements of the target resource. If the timing is an Age, the activity is expected to be performed when the subject is the given Age. When the timing is a Duration, the activity is expected to be performed within the specified duration from the apply. When the timing is a Range, it may be a range of Ages or Durations, providing a range for the expected timing of the resulting activity. When the timing is a Timing, it is establishing a schedule for the timing of the resulting activity.
    /// </summary>
    public Duration TimingDuration { get; set; }
    /// <summary>
    /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Descriptive topics related to the content of the activity. Topics provide a high-level categorization of the activity that can be useful for filtering and searching.
    /// </summary>
    public List<CodeableConcept> Topic { get; set; }
    /// <summary>
    /// Note that if both a transform and dynamic values are specified, the dynamic values will be applied to the result of the transform.
    /// </summary>
    public string Transform { get; set; }
    /// <summary>
    /// Extension container element for Transform
    /// </summary>
    public Element _Transform { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
    /// The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
    /// In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// A detailed description of how the activity definition is used from a clinical perspective.
    /// </summary>
    public string Usage { get; set; }
    /// <summary>
    /// Extension container element for Usage
    /// </summary>
    public Element _Usage { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// There may be different activity definition instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the activity definition with the format [url]|[version].
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Version))
      {
        writer.WriteString("version", (string)Version!);
      }

      if (_Version != null)
      {
        writer.WritePropertyName("_version");
        _Version.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Subtitle))
      {
        writer.WriteString("subtitle", (string)Subtitle!);
      }

      if (_Subtitle != null)
      {
        writer.WritePropertyName("_subtitle");
        _Subtitle.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Experimental != null)
      {
        writer.WriteBoolean("experimental", (bool)Experimental!);
      }

      if (_Experimental != null)
      {
        writer.WritePropertyName("_experimental");
        _Experimental.SerializeJson(writer, options);
      }

      if (SubjectCodeableConcept != null)
      {
        writer.WritePropertyName("subjectCodeableConcept");
        SubjectCodeableConcept.SerializeJson(writer, options);
      }

      if (SubjectReference != null)
      {
        writer.WritePropertyName("subjectReference");
        SubjectReference.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SubjectCanonical))
      {
        writer.WriteString("subjectCanonical", (string)SubjectCanonical!);
      }

      if (_SubjectCanonical != null)
      {
        writer.WritePropertyName("_subjectCanonical");
        _SubjectCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Publisher))
      {
        writer.WriteString("publisher", (string)Publisher!);
      }

      if (_Publisher != null)
      {
        writer.WritePropertyName("_publisher");
        _Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Jurisdiction != null) && (Jurisdiction.Count != 0))
      {
        writer.WritePropertyName("jurisdiction");
        writer.WriteStartArray();

        foreach (CodeableConcept valJurisdiction in Jurisdiction)
        {
          valJurisdiction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Purpose))
      {
        writer.WriteString("purpose", (string)Purpose!);
      }

      if (_Purpose != null)
      {
        writer.WritePropertyName("_purpose");
        _Purpose.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Usage))
      {
        writer.WriteString("usage", (string)Usage!);
      }

      if (_Usage != null)
      {
        writer.WritePropertyName("_usage");
        _Usage.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Copyright))
      {
        writer.WriteString("copyright", (string)Copyright!);
      }

      if (_Copyright != null)
      {
        writer.WritePropertyName("_copyright");
        _Copyright.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ApprovalDate))
      {
        writer.WriteString("approvalDate", (string)ApprovalDate!);
      }

      if (_ApprovalDate != null)
      {
        writer.WritePropertyName("_approvalDate");
        _ApprovalDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(LastReviewDate))
      {
        writer.WriteString("lastReviewDate", (string)LastReviewDate!);
      }

      if (_LastReviewDate != null)
      {
        writer.WritePropertyName("_lastReviewDate");
        _LastReviewDate.SerializeJson(writer, options);
      }

      if (EffectivePeriod != null)
      {
        writer.WritePropertyName("effectivePeriod");
        EffectivePeriod.SerializeJson(writer, options);
      }

      if ((Topic != null) && (Topic.Count != 0))
      {
        writer.WritePropertyName("topic");
        writer.WriteStartArray();

        foreach (CodeableConcept valTopic in Topic)
        {
          valTopic.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Author != null) && (Author.Count != 0))
      {
        writer.WritePropertyName("author");
        writer.WriteStartArray();

        foreach (ContactDetail valAuthor in Author)
        {
          valAuthor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Editor != null) && (Editor.Count != 0))
      {
        writer.WritePropertyName("editor");
        writer.WriteStartArray();

        foreach (ContactDetail valEditor in Editor)
        {
          valEditor.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Reviewer != null) && (Reviewer.Count != 0))
      {
        writer.WritePropertyName("reviewer");
        writer.WriteStartArray();

        foreach (ContactDetail valReviewer in Reviewer)
        {
          valReviewer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Endorser != null) && (Endorser.Count != 0))
      {
        writer.WritePropertyName("endorser");
        writer.WriteStartArray();

        foreach (ContactDetail valEndorser in Endorser)
        {
          valEndorser.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((RelatedArtifact != null) && (RelatedArtifact.Count != 0))
      {
        writer.WritePropertyName("relatedArtifact");
        writer.WriteStartArray();

        foreach (RelatedArtifact valRelatedArtifact in RelatedArtifact)
        {
          valRelatedArtifact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Library != null) && (Library.Count != 0))
      {
        writer.WritePropertyName("library");
        writer.WriteStartArray();

        foreach (string valLibrary in Library)
        {
          writer.WriteStringValue(valLibrary);
        }

        writer.WriteEndArray();
      }

      if ((_Library != null) && (_Library.Count != 0))
      {
        writer.WritePropertyName("_library");
        writer.WriteStartArray();

        foreach (Element val_Library in _Library)
        {
          val_Library.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Kind))
      {
        writer.WriteString("kind", (string)Kind!);
      }

      if (_Kind != null)
      {
        writer.WritePropertyName("_kind");
        _Kind.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Profile))
      {
        writer.WriteString("profile", (string)Profile!);
      }

      if (_Profile != null)
      {
        writer.WritePropertyName("_profile");
        _Profile.SerializeJson(writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Intent))
      {
        writer.WriteString("intent", (string)Intent!);
      }

      if (_Intent != null)
      {
        writer.WritePropertyName("_intent");
        _Intent.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Priority))
      {
        writer.WriteString("priority", (string)Priority!);
      }

      if (_Priority != null)
      {
        writer.WritePropertyName("_priority");
        _Priority.SerializeJson(writer, options);
      }

      if (DoNotPerform != null)
      {
        writer.WriteBoolean("doNotPerform", (bool)DoNotPerform!);
      }

      if (_DoNotPerform != null)
      {
        writer.WritePropertyName("_doNotPerform");
        _DoNotPerform.SerializeJson(writer, options);
      }

      if (TimingTiming != null)
      {
        writer.WritePropertyName("timingTiming");
        TimingTiming.SerializeJson(writer, options);
      }

      if (TimingAge != null)
      {
        writer.WritePropertyName("timingAge");
        TimingAge.SerializeJson(writer, options);
      }

      if (TimingRange != null)
      {
        writer.WritePropertyName("timingRange");
        TimingRange.SerializeJson(writer, options);
      }

      if (TimingDuration != null)
      {
        writer.WritePropertyName("timingDuration");
        TimingDuration.SerializeJson(writer, options);
      }

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(writer, options);
      }

      if ((Participant != null) && (Participant.Count != 0))
      {
        writer.WritePropertyName("participant");
        writer.WriteStartArray();

        foreach (ActivityDefinitionParticipant valParticipant in Participant)
        {
          valParticipant.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ProductReference != null)
      {
        writer.WritePropertyName("productReference");
        ProductReference.SerializeJson(writer, options);
      }

      if (ProductCodeableConcept != null)
      {
        writer.WritePropertyName("productCodeableConcept");
        ProductCodeableConcept.SerializeJson(writer, options);
      }

      if (Quantity != null)
      {
        writer.WritePropertyName("quantity");
        Quantity.SerializeJson(writer, options);
      }

      if ((Dosage != null) && (Dosage.Count != 0))
      {
        writer.WritePropertyName("dosage");
        writer.WriteStartArray();

        foreach (Dosage valDosage in Dosage)
        {
          valDosage.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BodySite != null) && (BodySite.Count != 0))
      {
        writer.WritePropertyName("bodySite");
        writer.WriteStartArray();

        foreach (CodeableConcept valBodySite in BodySite)
        {
          valBodySite.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((SpecimenRequirement != null) && (SpecimenRequirement.Count != 0))
      {
        writer.WritePropertyName("specimenRequirement");
        writer.WriteStartArray();

        foreach (Reference valSpecimenRequirement in SpecimenRequirement)
        {
          valSpecimenRequirement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ObservationRequirement != null) && (ObservationRequirement.Count != 0))
      {
        writer.WritePropertyName("observationRequirement");
        writer.WriteStartArray();

        foreach (Reference valObservationRequirement in ObservationRequirement)
        {
          valObservationRequirement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ObservationResultRequirement != null) && (ObservationResultRequirement.Count != 0))
      {
        writer.WritePropertyName("observationResultRequirement");
        writer.WriteStartArray();

        foreach (Reference valObservationResultRequirement in ObservationResultRequirement)
        {
          valObservationResultRequirement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Transform))
      {
        writer.WriteString("transform", (string)Transform!);
      }

      if (_Transform != null)
      {
        writer.WritePropertyName("_transform");
        _Transform.SerializeJson(writer, options);
      }

      if ((DynamicValue != null) && (DynamicValue.Count != 0))
      {
        writer.WritePropertyName("dynamicValue");
        writer.WriteStartArray();

        foreach (ActivityDefinitionDynamicValue valDynamicValue in DynamicValue)
        {
          valDynamicValue.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "approvalDate":
          ApprovalDate = reader.GetString();
          break;

        case "_approvalDate":
          _ApprovalDate = new fhirCsR5.Models.Element();
          _ApprovalDate.DeserializeJson(ref reader, options);
          break;

        case "author":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Author = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objAuthor = new fhirCsR5.Models.ContactDetail();
            objAuthor.DeserializeJson(ref reader, options);
            Author.Add(objAuthor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Author.Count == 0)
          {
            Author = null;
          }

          break;

        case "bodySite":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BodySite = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objBodySite = new fhirCsR5.Models.CodeableConcept();
            objBodySite.DeserializeJson(ref reader, options);
            BodySite.Add(objBodySite);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BodySite.Count == 0)
          {
            BodySite = null;
          }

          break;

        case "code":
          Code = new fhirCsR5.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objContact = new fhirCsR5.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "copyright":
          Copyright = reader.GetString();
          break;

        case "_copyright":
          _Copyright = new fhirCsR5.Models.Element();
          _Copyright.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR5.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR5.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "doNotPerform":
          DoNotPerform = reader.GetBoolean();
          break;

        case "_doNotPerform":
          _DoNotPerform = new fhirCsR5.Models.Element();
          _DoNotPerform.DeserializeJson(ref reader, options);
          break;

        case "dosage":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Dosage = new List<Dosage>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Dosage objDosage = new fhirCsR5.Models.Dosage();
            objDosage.DeserializeJson(ref reader, options);
            Dosage.Add(objDosage);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Dosage.Count == 0)
          {
            Dosage = null;
          }

          break;

        case "dynamicValue":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DynamicValue = new List<ActivityDefinitionDynamicValue>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ActivityDefinitionDynamicValue objDynamicValue = new fhirCsR5.Models.ActivityDefinitionDynamicValue();
            objDynamicValue.DeserializeJson(ref reader, options);
            DynamicValue.Add(objDynamicValue);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DynamicValue.Count == 0)
          {
            DynamicValue = null;
          }

          break;

        case "editor":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Editor = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objEditor = new fhirCsR5.Models.ContactDetail();
            objEditor.DeserializeJson(ref reader, options);
            Editor.Add(objEditor);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Editor.Count == 0)
          {
            Editor = null;
          }

          break;

        case "effectivePeriod":
          EffectivePeriod = new fhirCsR5.Models.Period();
          EffectivePeriod.DeserializeJson(ref reader, options);
          break;

        case "endorser":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Endorser = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objEndorser = new fhirCsR5.Models.ContactDetail();
            objEndorser.DeserializeJson(ref reader, options);
            Endorser.Add(objEndorser);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Endorser.Count == 0)
          {
            Endorser = null;
          }

          break;

        case "experimental":
          Experimental = reader.GetBoolean();
          break;

        case "_experimental":
          _Experimental = new fhirCsR5.Models.Element();
          _Experimental.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "intent":
          Intent = reader.GetString();
          break;

        case "_intent":
          _Intent = new fhirCsR5.Models.Element();
          _Intent.DeserializeJson(ref reader, options);
          break;

        case "jurisdiction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Jurisdiction = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objJurisdiction = new fhirCsR5.Models.CodeableConcept();
            objJurisdiction.DeserializeJson(ref reader, options);
            Jurisdiction.Add(objJurisdiction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Jurisdiction.Count == 0)
          {
            Jurisdiction = null;
          }

          break;

        case "kind":
          Kind = reader.GetString();
          break;

        case "_kind":
          _Kind = new fhirCsR5.Models.Element();
          _Kind.DeserializeJson(ref reader, options);
          break;

        case "lastReviewDate":
          LastReviewDate = reader.GetString();
          break;

        case "_lastReviewDate":
          _LastReviewDate = new fhirCsR5.Models.Element();
          _LastReviewDate.DeserializeJson(ref reader, options);
          break;

        case "library":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Library = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Library.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Library.Count == 0)
          {
            Library = null;
          }

          break;

        case "_library":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _Library = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_Library = new fhirCsR5.Models.Element();
            obj_Library.DeserializeJson(ref reader, options);
            _Library.Add(obj_Library);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_Library.Count == 0)
          {
            _Library = null;
          }

          break;

        case "location":
          Location = new fhirCsR5.Models.CodeableReference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR5.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "observationRequirement":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ObservationRequirement = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objObservationRequirement = new fhirCsR5.Models.Reference();
            objObservationRequirement.DeserializeJson(ref reader, options);
            ObservationRequirement.Add(objObservationRequirement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ObservationRequirement.Count == 0)
          {
            ObservationRequirement = null;
          }

          break;

        case "observationResultRequirement":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ObservationResultRequirement = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objObservationResultRequirement = new fhirCsR5.Models.Reference();
            objObservationResultRequirement.DeserializeJson(ref reader, options);
            ObservationResultRequirement.Add(objObservationResultRequirement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ObservationResultRequirement.Count == 0)
          {
            ObservationResultRequirement = null;
          }

          break;

        case "participant":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Participant = new List<ActivityDefinitionParticipant>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ActivityDefinitionParticipant objParticipant = new fhirCsR5.Models.ActivityDefinitionParticipant();
            objParticipant.DeserializeJson(ref reader, options);
            Participant.Add(objParticipant);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Participant.Count == 0)
          {
            Participant = null;
          }

          break;

        case "priority":
          Priority = reader.GetString();
          break;

        case "_priority":
          _Priority = new fhirCsR5.Models.Element();
          _Priority.DeserializeJson(ref reader, options);
          break;

        case "productReference":
          ProductReference = new fhirCsR5.Models.Reference();
          ProductReference.DeserializeJson(ref reader, options);
          break;

        case "productCodeableConcept":
          ProductCodeableConcept = new fhirCsR5.Models.CodeableConcept();
          ProductCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "profile":
          Profile = reader.GetString();
          break;

        case "_profile":
          _Profile = new fhirCsR5.Models.Element();
          _Profile.DeserializeJson(ref reader, options);
          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new fhirCsR5.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "purpose":
          Purpose = reader.GetString();
          break;

        case "_purpose":
          _Purpose = new fhirCsR5.Models.Element();
          _Purpose.DeserializeJson(ref reader, options);
          break;

        case "quantity":
          Quantity = new fhirCsR5.Models.Quantity();
          Quantity.DeserializeJson(ref reader, options);
          break;

        case "relatedArtifact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          RelatedArtifact = new List<RelatedArtifact>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.RelatedArtifact objRelatedArtifact = new fhirCsR5.Models.RelatedArtifact();
            objRelatedArtifact.DeserializeJson(ref reader, options);
            RelatedArtifact.Add(objRelatedArtifact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (RelatedArtifact.Count == 0)
          {
            RelatedArtifact = null;
          }

          break;

        case "reviewer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reviewer = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objReviewer = new fhirCsR5.Models.ContactDetail();
            objReviewer.DeserializeJson(ref reader, options);
            Reviewer.Add(objReviewer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reviewer.Count == 0)
          {
            Reviewer = null;
          }

          break;

        case "specimenRequirement":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SpecimenRequirement = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objSpecimenRequirement = new fhirCsR5.Models.Reference();
            objSpecimenRequirement.DeserializeJson(ref reader, options);
            SpecimenRequirement.Add(objSpecimenRequirement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SpecimenRequirement.Count == 0)
          {
            SpecimenRequirement = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subjectCodeableConcept":
          SubjectCodeableConcept = new fhirCsR5.Models.CodeableConcept();
          SubjectCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "subjectReference":
          SubjectReference = new fhirCsR5.Models.Reference();
          SubjectReference.DeserializeJson(ref reader, options);
          break;

        case "subjectCanonical":
          SubjectCanonical = reader.GetString();
          break;

        case "_subjectCanonical":
          _SubjectCanonical = new fhirCsR5.Models.Element();
          _SubjectCanonical.DeserializeJson(ref reader, options);
          break;

        case "subtitle":
          Subtitle = reader.GetString();
          break;

        case "_subtitle":
          _Subtitle = new fhirCsR5.Models.Element();
          _Subtitle.DeserializeJson(ref reader, options);
          break;

        case "timingTiming":
          TimingTiming = new fhirCsR5.Models.Timing();
          TimingTiming.DeserializeJson(ref reader, options);
          break;

        case "timingAge":
          TimingAge = new fhirCsR5.Models.Age();
          TimingAge.DeserializeJson(ref reader, options);
          break;

        case "timingRange":
          TimingRange = new fhirCsR5.Models.Range();
          TimingRange.DeserializeJson(ref reader, options);
          break;

        case "timingDuration":
          TimingDuration = new fhirCsR5.Models.Duration();
          TimingDuration.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR5.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "topic":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Topic = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objTopic = new fhirCsR5.Models.CodeableConcept();
            objTopic.DeserializeJson(ref reader, options);
            Topic.Add(objTopic);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Topic.Count == 0)
          {
            Topic = null;
          }

          break;

        case "transform":
          Transform = reader.GetString();
          break;

        case "_transform":
          _Transform = new fhirCsR5.Models.Element();
          _Transform.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR5.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "usage":
          Usage = reader.GetString();
          break;

        case "_usage":
          _Usage = new fhirCsR5.Models.Element();
          _Usage.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.UsageContext objUseContext = new fhirCsR5.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new fhirCsR5.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ActivityDefinition.intent field
  /// </summary>
  public static class ActivityDefinitionIntentCodes {
    public const string PROPOSAL = "proposal";
    public const string PLAN = "plan";
    public const string DIRECTIVE = "directive";
    public const string ORDER = "order";
    public const string ORIGINAL_ORDER = "original-order";
    public const string REFLEX_ORDER = "reflex-order";
    public const string FILLER_ORDER = "filler-order";
    public const string INSTANCE_ORDER = "instance-order";
    public const string OPTION = "option";
    public static HashSet<string> Values = new HashSet<string>() {
      "proposal",
      "plan",
      "directive",
      "order",
      "original-order",
      "reflex-order",
      "filler-order",
      "instance-order",
      "option",
    };
  }
  /// <summary>
  /// Code Values for the ActivityDefinition.priority field
  /// </summary>
  public static class ActivityDefinitionPriorityCodes {
    public const string ROUTINE = "routine";
    public const string URGENT = "urgent";
    public const string ASAP = "asap";
    public const string STAT = "stat";
    public static HashSet<string> Values = new HashSet<string>() {
      "routine",
      "urgent",
      "asap",
      "stat",
    };
  }
  /// <summary>
  /// Code Values for the ActivityDefinition.status field
  /// </summary>
  public static class ActivityDefinitionStatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "draft",
      "active",
      "retired",
      "unknown",
    };
  }
}
