// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// Related artifacts such as additional documentation, justification, or bibliographic references.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<RelatedArtifact>))]
  public class RelatedArtifact : DataType,  IFhirJsonSerializable {
    /// <summary>
    /// Additional structured information about citations should be captured as extensions.
    /// </summary>
    public string Citation { get; set; }
    /// <summary>
    /// Extension container element for Citation
    /// </summary>
    public Element _Citation { get; set; }
    /// <summary>
    /// Provides additional classifiers of the related artifact.
    /// </summary>
    public List<CodeableConcept> Classifier { get; set; }
    /// <summary>
    /// A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// The document being referenced, represented as an attachment. This is exclusive with the resource element.
    /// </summary>
    public Attachment Document { get; set; }
    /// <summary>
    /// A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
    /// </summary>
    public string Label { get; set; }
    /// <summary>
    /// Extension container element for Label
    /// </summary>
    public Element _Label { get; set; }
    /// <summary>
    /// If the type is predecessor, this is a reference to the succeeding knowledge resource. If the type is successor, this is a reference to the prior knowledge resource.
    /// </summary>
    public string Resource { get; set; }
    /// <summary>
    /// Extension container element for Resource
    /// </summary>
    public Element _Resource { get; set; }
    /// <summary>
    /// If both resource and resourceReference are present, they SHOULD be consistent and reference the same resource. Although relatedArtifact is intended to support references to definitional resources, there are cases where non-definitional resources can be definitional (such as Location where the kind is mode). Related artifacts SHOULD be used to reference definitional resources, and profiles SHOULD be used to make that explicit for particular use cases.
    /// </summary>
    public Reference ResourceReference { get; set; }
    /// <summary>
    /// The presence of both sides of a relationship type (e.g. successor and predecessor) is required to support use cases where one side of a relationship is not represented in FHIR. However, this feature SHALL NOT be used to create bi-directional resource links in FHIR instances.
    /// </summary>
    public string Type { get; set; }
    /// <summary>
    /// Extension container element for Type
    /// </summary>
    public Element _Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.DataType)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Type))
      {
        writer.WriteString("type", (string)Type!);
      }

      if (_Type != null)
      {
        writer.WritePropertyName("_type");
        _Type.SerializeJson(writer, options);
      }

      if ((Classifier != null) && (Classifier.Count != 0))
      {
        writer.WritePropertyName("classifier");
        writer.WriteStartArray();

        foreach (CodeableConcept valClassifier in Classifier)
        {
          valClassifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Label))
      {
        writer.WriteString("label", (string)Label!);
      }

      if (_Label != null)
      {
        writer.WritePropertyName("_label");
        _Label.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Citation))
      {
        writer.WriteString("citation", (string)Citation!);
      }

      if (_Citation != null)
      {
        writer.WritePropertyName("_citation");
        _Citation.SerializeJson(writer, options);
      }

      if (Document != null)
      {
        writer.WritePropertyName("document");
        Document.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Resource))
      {
        writer.WriteString("resource", (string)Resource!);
      }

      if (_Resource != null)
      {
        writer.WritePropertyName("_resource");
        _Resource.SerializeJson(writer, options);
      }

      if (ResourceReference != null)
      {
        writer.WritePropertyName("resourceReference");
        ResourceReference.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "citation":
          Citation = reader.GetString();
          break;

        case "_citation":
          _Citation = new fhirCsR5.Models.Element();
          _Citation.DeserializeJson(ref reader, options);
          break;

        case "classifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Classifier = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objClassifier = new fhirCsR5.Models.CodeableConcept();
            objClassifier.DeserializeJson(ref reader, options);
            Classifier.Add(objClassifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Classifier.Count == 0)
          {
            Classifier = null;
          }

          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR5.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "document":
          Document = new fhirCsR5.Models.Attachment();
          Document.DeserializeJson(ref reader, options);
          break;

        case "label":
          Label = reader.GetString();
          break;

        case "_label":
          _Label = new fhirCsR5.Models.Element();
          _Label.DeserializeJson(ref reader, options);
          break;

        case "resource":
          Resource = reader.GetString();
          break;

        case "_resource":
          _Resource = new fhirCsR5.Models.Element();
          _Resource.DeserializeJson(ref reader, options);
          break;

        case "resourceReference":
          ResourceReference = new fhirCsR5.Models.Reference();
          ResourceReference.DeserializeJson(ref reader, options);
          break;

        case "type":
          Type = reader.GetString();
          break;

        case "_type":
          _Type = new fhirCsR5.Models.Element();
          _Type.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DataType)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the RelatedArtifact.type field
  /// </summary>
  public static class RelatedArtifactTypeCodes {
    public const string DOCUMENTATION = "documentation";
    public const string JUSTIFICATION = "justification";
    public const string CITATION = "citation";
    public const string PREDECESSOR = "predecessor";
    public const string SUCCESSOR = "successor";
    public const string DERIVED_FROM = "derived-from";
    public const string DEPENDS_ON = "depends-on";
    public const string COMPOSED_OF = "composed-of";
    public const string PART_OF = "part-of";
    public const string AMENDS = "amends";
    public const string AMENDED_WITH = "amended-with";
    public const string APPENDS = "appends";
    public const string APPENDED_WITH = "appended-with";
    public const string CITES = "cites";
    public const string CITED_BY = "cited-by";
    public const string COMMENTS_ON = "comments-on";
    public const string COMMENT_IN = "comment-in";
    public const string CONTAINS = "contains";
    public const string CONTAINED_IN = "contained-in";
    public const string CORRECTS = "corrects";
    public const string CORRECTION_IN = "correction-in";
    public const string REPLACES = "replaces";
    public const string REPLACED_WITH = "replaced-with";
    public const string RETRACTS = "retracts";
    public const string RETRACTED_BY = "retracted-by";
    public const string SIGNS = "signs";
    public const string SIMILAR_TO = "similar-to";
    public const string SUPPORTS = "supports";
    public const string SUPPORTED_WITH = "supported-with";
    public const string TRANSFORMS = "transforms";
    public const string TRANSFORMED_INTO = "transformed-into";
    public const string TRANSFORMED_WITH = "transformed-with";
    public static HashSet<string> Values = new HashSet<string>() {
      "documentation",
      "justification",
      "citation",
      "predecessor",
      "successor",
      "derived-from",
      "depends-on",
      "composed-of",
      "part-of",
      "amends",
      "amended-with",
      "appends",
      "appended-with",
      "cites",
      "cited-by",
      "comments-on",
      "comment-in",
      "contains",
      "contained-in",
      "corrects",
      "correction-in",
      "replaces",
      "replaced-with",
      "retracts",
      "retracted-by",
      "signs",
      "similar-to",
      "supports",
      "supported-with",
      "transforms",
      "transformed-into",
      "transformed-with",
    };
  }
}
