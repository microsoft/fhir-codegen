// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2GroupElementTargetDependsOn>))]
  public class ConceptMap2GroupElementTargetDependsOn : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somewhere that is labeled to correspond with a code system property.
    /// </summary>
    public string Property { get; set; }
    /// <summary>
    /// Extension container element for Property
    /// </summary>
    public Element _Property { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public string ValueCode { get; set; }
    /// <summary>
    /// Extension container element for ValueCode
    /// </summary>
    public Element _ValueCode { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public Coding ValueCoding { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public string ValueString { get; set; }
    /// <summary>
    /// Extension container element for ValueString
    /// </summary>
    public Element _ValueString { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public int? ValueInteger { get; set; }
    /// <summary>
    /// Extension container element for ValueInteger
    /// </summary>
    public Element _ValueInteger { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public bool? ValueBoolean { get; set; }
    /// <summary>
    /// Extension container element for ValueBoolean
    /// </summary>
    public Element _ValueBoolean { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public string ValueDateTime { get; set; }
    /// <summary>
    /// Extension container element for ValueDateTime
    /// </summary>
    public Element _ValueDateTime { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public decimal? ValueDecimal { get; set; }
    /// <summary>
    /// Extension container element for ValueDecimal
    /// </summary>
    public Element _ValueDecimal { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public string ValueUri { get; set; }
    /// <summary>
    /// Extension container element for ValueUri
    /// </summary>
    public Element _ValueUri { get; set; }
    /// <summary>
    /// Property value that the map depends on.
    /// </summary>
    public string ValueId { get; set; }
    /// <summary>
    /// Extension container element for ValueId
    /// </summary>
    public Element _ValueId { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Property))
      {
        writer.WriteString("property", (string)Property!);
      }

      if (_Property != null)
      {
        writer.WritePropertyName("_property");
        _Property.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueCode))
      {
        writer.WriteString("valueCode", (string)ValueCode!);
      }

      if (_ValueCode != null)
      {
        writer.WritePropertyName("_valueCode");
        _ValueCode.SerializeJson(writer, options);
      }

      if (ValueCoding != null)
      {
        writer.WritePropertyName("valueCoding");
        ValueCoding.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueString))
      {
        writer.WriteString("valueString", (string)ValueString!);
      }

      if (_ValueString != null)
      {
        writer.WritePropertyName("_valueString");
        _ValueString.SerializeJson(writer, options);
      }

      if (ValueInteger != null)
      {
        writer.WriteNumber("valueInteger", (int)ValueInteger!);
      }

      if (_ValueInteger != null)
      {
        writer.WritePropertyName("_valueInteger");
        _ValueInteger.SerializeJson(writer, options);
      }

      if (ValueBoolean != null)
      {
        writer.WriteBoolean("valueBoolean", (bool)ValueBoolean!);
      }

      if (_ValueBoolean != null)
      {
        writer.WritePropertyName("_valueBoolean");
        _ValueBoolean.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueDateTime))
      {
        writer.WriteString("valueDateTime", (string)ValueDateTime!);
      }

      if (_ValueDateTime != null)
      {
        writer.WritePropertyName("_valueDateTime");
        _ValueDateTime.SerializeJson(writer, options);
      }

      if (ValueDecimal != null)
      {
        writer.WriteNumber("valueDecimal", (decimal)ValueDecimal!);
      }

      if (_ValueDecimal != null)
      {
        writer.WritePropertyName("_valueDecimal");
        _ValueDecimal.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueUri))
      {
        writer.WriteString("valueUri", (string)ValueUri!);
      }

      if (_ValueUri != null)
      {
        writer.WritePropertyName("_valueUri");
        _ValueUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueId))
      {
        writer.WriteString("valueId", (string)ValueId!);
      }

      if (_ValueId != null)
      {
        writer.WritePropertyName("_valueId");
        _ValueId.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "property":
          Property = reader.GetString();
          break;

        case "_property":
          _Property = new fhirCsR5.Models.Element();
          _Property.DeserializeJson(ref reader, options);
          break;

        case "valueCode":
          ValueCode = reader.GetString();
          break;

        case "_valueCode":
          _ValueCode = new fhirCsR5.Models.Element();
          _ValueCode.DeserializeJson(ref reader, options);
          break;

        case "valueCoding":
          ValueCoding = new fhirCsR5.Models.Coding();
          ValueCoding.DeserializeJson(ref reader, options);
          break;

        case "valueString":
          ValueString = reader.GetString();
          break;

        case "_valueString":
          _ValueString = new fhirCsR5.Models.Element();
          _ValueString.DeserializeJson(ref reader, options);
          break;

        case "valueInteger":
          ValueInteger = reader.GetInt32();
          break;

        case "_valueInteger":
          _ValueInteger = new fhirCsR5.Models.Element();
          _ValueInteger.DeserializeJson(ref reader, options);
          break;

        case "valueBoolean":
          ValueBoolean = reader.GetBoolean();
          break;

        case "_valueBoolean":
          _ValueBoolean = new fhirCsR5.Models.Element();
          _ValueBoolean.DeserializeJson(ref reader, options);
          break;

        case "valueDateTime":
          ValueDateTime = reader.GetString();
          break;

        case "_valueDateTime":
          _ValueDateTime = new fhirCsR5.Models.Element();
          _ValueDateTime.DeserializeJson(ref reader, options);
          break;

        case "valueDecimal":
          ValueDecimal = reader.GetDecimal();
          break;

        case "_valueDecimal":
          _ValueDecimal = new fhirCsR5.Models.Element();
          _ValueDecimal.DeserializeJson(ref reader, options);
          break;

        case "valueUri":
          ValueUri = reader.GetString();
          break;

        case "_valueUri":
          _ValueUri = new fhirCsR5.Models.Element();
          _ValueUri.DeserializeJson(ref reader, options);
          break;

        case "valueId":
          ValueId = reader.GetString();
          break;

        case "_valueId":
          _ValueId = new fhirCsR5.Models.Element();
          _ValueId.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Ideally there would only be one map, with an 'equivalent' mapping. But multiple maps are allowed for several narrower (i.e. source-is-broader-than-target) options, or to assert that other concepts are not related.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2GroupElementTarget>))]
  public class ConceptMap2GroupElementTarget : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identity (code or path) or the element/item that the map refers to.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    /// </summary>
    public List<ConceptMap2GroupElementTargetDependsOn> DependsOn { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the relationship (e.g., equivalent) cannot be relied on.
    /// </summary>
    public List<ConceptMap2GroupElementTargetDependsOn> Product { get; set; }
    /// <summary>
    /// This element is labeled as a modifier because it may indicate that there is no mapping.
    /// </summary>
    public string Relationship { get; set; }
    /// <summary>
    /// Extension container element for Relationship
    /// </summary>
    public Element _Relationship { get; set; }
    /// <summary>
    /// The set of codes being that the map refers to.
    /// </summary>
    public string ValueSet { get; set; }
    /// <summary>
    /// Extension container element for ValueSet
    /// </summary>
    public Element _ValueSet { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueSet))
      {
        writer.WriteString("valueSet", (string)ValueSet!);
      }

      if (_ValueSet != null)
      {
        writer.WritePropertyName("_valueSet");
        _ValueSet.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Relationship))
      {
        writer.WriteString("relationship", (string)Relationship!);
      }

      if (_Relationship != null)
      {
        writer.WritePropertyName("_relationship");
        _Relationship.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if ((DependsOn != null) && (DependsOn.Count != 0))
      {
        writer.WritePropertyName("dependsOn");
        writer.WriteStartArray();

        foreach (ConceptMap2GroupElementTargetDependsOn valDependsOn in DependsOn)
        {
          valDependsOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Product != null) && (Product.Count != 0))
      {
        writer.WritePropertyName("product");
        writer.WriteStartArray();

        foreach (ConceptMap2GroupElementTargetDependsOn valProduct in Product)
        {
          valProduct.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR5.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR5.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "dependsOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DependsOn = new List<ConceptMap2GroupElementTargetDependsOn>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ConceptMap2GroupElementTargetDependsOn objDependsOn = new fhirCsR5.Models.ConceptMap2GroupElementTargetDependsOn();
            objDependsOn.DeserializeJson(ref reader, options);
            DependsOn.Add(objDependsOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DependsOn.Count == 0)
          {
            DependsOn = null;
          }

          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR5.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "product":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Product = new List<ConceptMap2GroupElementTargetDependsOn>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ConceptMap2GroupElementTargetDependsOn objProduct = new fhirCsR5.Models.ConceptMap2GroupElementTargetDependsOn();
            objProduct.DeserializeJson(ref reader, options);
            Product.Add(objProduct);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Product.Count == 0)
          {
            Product = null;
          }

          break;

        case "relationship":
          Relationship = reader.GetString();
          break;

        case "_relationship":
          _Relationship = new fhirCsR5.Models.Element();
          _Relationship.DeserializeJson(ref reader, options);
          break;

        case "valueSet":
          ValueSet = reader.GetString();
          break;

        case "_valueSet":
          _ValueSet = new fhirCsR5.Models.Element();
          _ValueSet.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap2.group.element.target.relationship field
  /// </summary>
  public static class ConceptMap2GroupElementTargetRelationshipCodes {
    public const string RELATED_TO = "related-to";
    public const string EQUIVALENT = "equivalent";
    public const string SOURCE_IS_NARROWER_THAN_TARGET = "source-is-narrower-than-target";
    public const string SOURCE_IS_BROADER_THAN_TARGET = "source-is-broader-than-target";
    public const string NOT_RELATED_TO = "not-related-to";
    public static HashSet<string> Values = new HashSet<string>() {
      "related-to",
      "equivalent",
      "source-is-narrower-than-target",
      "source-is-broader-than-target",
      "not-related-to",
    };
  }
  /// <summary>
  /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2GroupElement>))]
  public class ConceptMap2GroupElement : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identity (code or path) or the element/item being mapped.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// If noMap = true this indicates that no mapping to a target concept exists for this source concept.
    /// </summary>
    public bool? NoMap { get; set; }
    /// <summary>
    /// Extension container element for NoMap
    /// </summary>
    public Element _NoMap { get; set; }
    /// <summary>
    /// Ideally there would only be one map, with an 'equivalent' mapping. But multiple maps are allowed for several narrower (i.e. source-is-broader-than-target) options, or to assert that other concepts are not related.
    /// </summary>
    public List<ConceptMap2GroupElementTarget> Target { get; set; }
    /// <summary>
    /// The set of codes being mapped.
    /// </summary>
    public string ValueSet { get; set; }
    /// <summary>
    /// Extension container element for ValueSet
    /// </summary>
    public Element _ValueSet { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueSet))
      {
        writer.WriteString("valueSet", (string)ValueSet!);
      }

      if (_ValueSet != null)
      {
        writer.WritePropertyName("_valueSet");
        _ValueSet.SerializeJson(writer, options);
      }

      if (NoMap != null)
      {
        writer.WriteBoolean("noMap", (bool)NoMap!);
      }

      if (_NoMap != null)
      {
        writer.WritePropertyName("_noMap");
        _NoMap.SerializeJson(writer, options);
      }

      if ((Target != null) && (Target.Count != 0))
      {
        writer.WritePropertyName("target");
        writer.WriteStartArray();

        foreach (ConceptMap2GroupElementTarget valTarget in Target)
        {
          valTarget.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR5.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR5.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "noMap":
          NoMap = reader.GetBoolean();
          break;

        case "_noMap":
          _NoMap = new fhirCsR5.Models.Element();
          _NoMap.DeserializeJson(ref reader, options);
          break;

        case "target":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Target = new List<ConceptMap2GroupElementTarget>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ConceptMap2GroupElementTarget objTarget = new fhirCsR5.Models.ConceptMap2GroupElementTarget();
            objTarget.DeserializeJson(ref reader, options);
            Target.Add(objTarget);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Target.Count == 0)
          {
            Target = null;
          }

          break;

        case "valueSet":
          ValueSet = reader.GetString();
          break;

        case "_valueSet":
          _ValueSet = new fhirCsR5.Models.Element();
          _ValueSet.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// This only applies if the source code has a system value that matches the system defined for the group.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2GroupUnmapped>))]
  public class ConceptMap2GroupUnmapped : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// Defines which action to take if there is no match for the source concept in the target system designated for the group. One of 3 actions are possible: use the unmapped code (this is useful when doing a mapping between versions, and only a few codes have changed), use a fixed code (a default code), or alternatively, a reference to a different concept map can be provided (by canonical URL).
    /// </summary>
    public string Mode { get; set; }
    /// <summary>
    /// Extension container element for Mode
    /// </summary>
    public Element _Mode { get; set; }
    /// <summary>
    /// The canonical reference to an additional ConceptMap2 resource instance to use for mapping if this ConceptMap2 resource contains no matching mapping for the source concept.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// The set of fixed codes to use when the mode = 'fixed'  - all unmapped codes are mapped to a each of the fixed codes.
    /// </summary>
    public string ValueSet { get; set; }
    /// <summary>
    /// Extension container element for ValueSet
    /// </summary>
    public Element _ValueSet { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Mode))
      {
        writer.WriteString("mode", (string)Mode!);
      }

      if (_Mode != null)
      {
        writer.WritePropertyName("_mode");
        _Mode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValueSet))
      {
        writer.WriteString("valueSet", (string)ValueSet!);
      }

      if (_ValueSet != null)
      {
        writer.WritePropertyName("_valueSet");
        _ValueSet.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR5.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR5.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "mode":
          Mode = reader.GetString();
          break;

        case "_mode":
          _Mode = new fhirCsR5.Models.Element();
          _Mode.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR5.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "valueSet":
          ValueSet = reader.GetString();
          break;

        case "_valueSet":
          _ValueSet = new fhirCsR5.Models.Element();
          _ValueSet.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap2.group.unmapped.mode field
  /// </summary>
  public static class ConceptMap2GroupUnmappedModeCodes {
    public const string PROVIDED = "provided";
    public const string VAL_FIXED = "fixed";
    public const string OTHER_MAP = "other-map";
    public static HashSet<string> Values = new HashSet<string>() {
      "provided",
      "fixed",
      "other-map",
    };
  }
  /// <summary>
  /// A group of mappings that all have the same source and target system.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2Group>))]
  public class ConceptMap2Group : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
    /// </summary>
    public List<ConceptMap2GroupElement> Element { get; set; }
    /// <summary>
    /// This is not needed if the source value set is specified and it contains concepts from only a single system.
    /// </summary>
    public string Source { get; set; }
    /// <summary>
    /// Extension container element for Source
    /// </summary>
    public Element _Source { get; set; }
    /// <summary>
    /// This is not needed if the target value set is specified and it contains concepts from only a single system. The group target may also be omitted if all of the target element relationship values are 'not-related-to'.
    /// </summary>
    public string Target { get; set; }
    /// <summary>
    /// Extension container element for Target
    /// </summary>
    public Element _Target { get; set; }
    /// <summary>
    /// This only applies if the source code has a system value that matches the system defined for the group.
    /// </summary>
    public ConceptMap2GroupUnmapped Unmapped { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Source))
      {
        writer.WriteString("source", (string)Source!);
      }

      if (_Source != null)
      {
        writer.WritePropertyName("_source");
        _Source.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Target))
      {
        writer.WriteString("target", (string)Target!);
      }

      if (_Target != null)
      {
        writer.WritePropertyName("_target");
        _Target.SerializeJson(writer, options);
      }

      if ((Element != null) && (Element.Count != 0))
      {
        writer.WritePropertyName("element");
        writer.WriteStartArray();

        foreach (ConceptMap2GroupElement valElement in Element)
        {
          valElement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Unmapped != null)
      {
        writer.WritePropertyName("unmapped");
        Unmapped.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "element":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Element = new List<ConceptMap2GroupElement>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ConceptMap2GroupElement objElement = new fhirCsR5.Models.ConceptMap2GroupElement();
            objElement.DeserializeJson(ref reader, options);
            Element.Add(objElement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Element.Count == 0)
          {
            Element = null;
          }

          break;

        case "source":
          Source = reader.GetString();
          break;

        case "_source":
          _Source = new fhirCsR5.Models.Element();
          _Source.DeserializeJson(ref reader, options);
          break;

        case "target":
          Target = reader.GetString();
          break;

        case "_target":
          _Target = new fhirCsR5.Models.Element();
          _Target.DeserializeJson(ref reader, options);
          break;

        case "unmapped":
          Unmapped = new fhirCsR5.Models.ConceptMap2GroupUnmapped();
          Unmapped.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ConceptMap2>))]
  public class ConceptMap2 : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ConceptMap2";
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// Frequently the copyright differs between the concept map and codes that are included. The copyright statement should clearly differentiate between these when required.
    /// </summary>
    public string Copyright { get; set; }
    /// <summary>
    /// Extension container element for Copyright
    /// </summary>
    public Element _Copyright { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the concept map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// The description is not intended to describe the semantics of the concept map. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Allows filtering of concept maps that are appropriate for use versus not.
    /// </summary>
    public bool? Experimental { get; set; }
    /// <summary>
    /// Extension container element for Experimental
    /// </summary>
    public Element _Experimental { get; set; }
    /// <summary>
    /// A group of mappings that all have the same source and target system.
    /// </summary>
    public List<ConceptMap2Group> Group { get; set; }
    /// <summary>
    /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this concept map outside of FHIR, where it is not possible to use the logical URI.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// It may be possible for the concept map to be used in jurisdictions other than those for which it was originally designed or intended.
    /// </summary>
    public List<CodeableConcept> Jurisdiction { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the concept map is the organization or individual primarily responsible for the maintenance and upkeep of the concept map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the concept map. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// This element does not describe the usage of the concept map. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this concept map.
    /// </summary>
    public string Purpose { get; set; }
    /// <summary>
    /// Extension container element for Purpose
    /// </summary>
    public Element _Purpose { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, there is no specified context for the map (not recommended).  The source value set may select codes from either an explicit (standard or local) or implicit code system.
    /// </summary>
    public string SourceUri { get; set; }
    /// <summary>
    /// Extension container element for SourceUri
    /// </summary>
    public Element _SourceUri { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, there is no specified context for the map (not recommended).  The source value set may select codes from either an explicit (standard or local) or implicit code system.
    /// </summary>
    public string SourceCanonical { get; set; }
    /// <summary>
    /// Extension container element for SourceCanonical
    /// </summary>
    public Element _SourceCanonical { get; set; }
    /// <summary>
    /// Allows filtering of concept maps that are appropriate for use versus not.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
    /// </summary>
    public string TargetUri { get; set; }
    /// <summary>
    /// Extension container element for TargetUri
    /// </summary>
    public Element _TargetUri { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
    /// </summary>
    public string TargetCanonical { get; set; }
    /// <summary>
    /// Extension container element for TargetCanonical
    /// </summary>
    public Element _TargetCanonical { get; set; }
    /// <summary>
    /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
    /// The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
    /// In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// There may be different concept map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the concept map with the format [url]|[version].
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Version))
      {
        writer.WriteString("version", (string)Version!);
      }

      if (_Version != null)
      {
        writer.WritePropertyName("_version");
        _Version.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Experimental != null)
      {
        writer.WriteBoolean("experimental", (bool)Experimental!);
      }

      if (_Experimental != null)
      {
        writer.WritePropertyName("_experimental");
        _Experimental.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Publisher))
      {
        writer.WriteString("publisher", (string)Publisher!);
      }

      if (_Publisher != null)
      {
        writer.WritePropertyName("_publisher");
        _Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Jurisdiction != null) && (Jurisdiction.Count != 0))
      {
        writer.WritePropertyName("jurisdiction");
        writer.WriteStartArray();

        foreach (CodeableConcept valJurisdiction in Jurisdiction)
        {
          valJurisdiction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Purpose))
      {
        writer.WriteString("purpose", (string)Purpose!);
      }

      if (_Purpose != null)
      {
        writer.WritePropertyName("_purpose");
        _Purpose.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Copyright))
      {
        writer.WriteString("copyright", (string)Copyright!);
      }

      if (_Copyright != null)
      {
        writer.WritePropertyName("_copyright");
        _Copyright.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SourceUri))
      {
        writer.WriteString("sourceUri", (string)SourceUri!);
      }

      if (_SourceUri != null)
      {
        writer.WritePropertyName("_sourceUri");
        _SourceUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SourceCanonical))
      {
        writer.WriteString("sourceCanonical", (string)SourceCanonical!);
      }

      if (_SourceCanonical != null)
      {
        writer.WritePropertyName("_sourceCanonical");
        _SourceCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TargetUri))
      {
        writer.WriteString("targetUri", (string)TargetUri!);
      }

      if (_TargetUri != null)
      {
        writer.WritePropertyName("_targetUri");
        _TargetUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TargetCanonical))
      {
        writer.WriteString("targetCanonical", (string)TargetCanonical!);
      }

      if (_TargetCanonical != null)
      {
        writer.WritePropertyName("_targetCanonical");
        _TargetCanonical.SerializeJson(writer, options);
      }

      if ((Group != null) && (Group.Count != 0))
      {
        writer.WritePropertyName("group");
        writer.WriteStartArray();

        foreach (ConceptMap2Group valGroup in Group)
        {
          valGroup.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objContact = new fhirCsR5.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "copyright":
          Copyright = reader.GetString();
          break;

        case "_copyright":
          _Copyright = new fhirCsR5.Models.Element();
          _Copyright.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR5.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR5.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "experimental":
          Experimental = reader.GetBoolean();
          break;

        case "_experimental":
          _Experimental = new fhirCsR5.Models.Element();
          _Experimental.DeserializeJson(ref reader, options);
          break;

        case "group":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Group = new List<ConceptMap2Group>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ConceptMap2Group objGroup = new fhirCsR5.Models.ConceptMap2Group();
            objGroup.DeserializeJson(ref reader, options);
            Group.Add(objGroup);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Group.Count == 0)
          {
            Group = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "jurisdiction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Jurisdiction = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objJurisdiction = new fhirCsR5.Models.CodeableConcept();
            objJurisdiction.DeserializeJson(ref reader, options);
            Jurisdiction.Add(objJurisdiction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Jurisdiction.Count == 0)
          {
            Jurisdiction = null;
          }

          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR5.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new fhirCsR5.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "purpose":
          Purpose = reader.GetString();
          break;

        case "_purpose":
          _Purpose = new fhirCsR5.Models.Element();
          _Purpose.DeserializeJson(ref reader, options);
          break;

        case "sourceUri":
          SourceUri = reader.GetString();
          break;

        case "_sourceUri":
          _SourceUri = new fhirCsR5.Models.Element();
          _SourceUri.DeserializeJson(ref reader, options);
          break;

        case "sourceCanonical":
          SourceCanonical = reader.GetString();
          break;

        case "_sourceCanonical":
          _SourceCanonical = new fhirCsR5.Models.Element();
          _SourceCanonical.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "targetUri":
          TargetUri = reader.GetString();
          break;

        case "_targetUri":
          _TargetUri = new fhirCsR5.Models.Element();
          _TargetUri.DeserializeJson(ref reader, options);
          break;

        case "targetCanonical":
          TargetCanonical = reader.GetString();
          break;

        case "_targetCanonical":
          _TargetCanonical = new fhirCsR5.Models.Element();
          _TargetCanonical.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR5.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR5.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.UsageContext objUseContext = new fhirCsR5.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new fhirCsR5.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap2.status field
  /// </summary>
  public static class ConceptMap2StatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "draft",
      "active",
      "retired",
      "unknown",
    };
  }
}
