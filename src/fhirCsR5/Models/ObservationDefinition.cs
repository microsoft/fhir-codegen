// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// Characteristics for quantitative results of observations conforming to this ObservationDefinition.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ObservationDefinitionQuantitativeDetails>))]
  public class ObservationDefinitionQuantitativeDetails : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Factor for converting value expressed with primary unit to value expressed with secondary unit.
    /// </summary>
    public decimal? ConversionFactor { get; set; }
    /// <summary>
    /// Extension container element for ConversionFactor
    /// </summary>
    public Element _ConversionFactor { get; set; }
    /// <summary>
    /// Secondary unit used to report quantitative results of observations conforming to this ObservationDefinition.
    /// </summary>
    public CodeableConcept CustomaryUnit { get; set; }
    /// <summary>
    /// Number of digits after decimal separator when the results of such observations are of type Quantity.
    /// </summary>
    public int? DecimalPrecision { get; set; }
    /// <summary>
    /// Extension container element for DecimalPrecision
    /// </summary>
    public Element _DecimalPrecision { get; set; }
    /// <summary>
    /// Primary unit used to report quantitative results of observations conforming to this ObservationDefinition.
    /// </summary>
    public CodeableConcept Unit { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Unit != null)
      {
        writer.WritePropertyName("unit");
        Unit.SerializeJson(writer, options);
      }

      if (CustomaryUnit != null)
      {
        writer.WritePropertyName("customaryUnit");
        CustomaryUnit.SerializeJson(writer, options);
      }

      if (ConversionFactor != null)
      {
        writer.WriteNumber("conversionFactor", (decimal)ConversionFactor!);
      }

      if (_ConversionFactor != null)
      {
        writer.WritePropertyName("_conversionFactor");
        _ConversionFactor.SerializeJson(writer, options);
      }

      if (DecimalPrecision != null)
      {
        writer.WriteNumber("decimalPrecision", (int)DecimalPrecision!);
      }

      if (_DecimalPrecision != null)
      {
        writer.WritePropertyName("_decimalPrecision");
        _DecimalPrecision.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "conversionFactor":
          ConversionFactor = reader.GetDecimal();
          break;

        case "_conversionFactor":
          _ConversionFactor = new fhirCsR5.Models.Element();
          _ConversionFactor.DeserializeJson(ref reader, options);
          break;

        case "customaryUnit":
          CustomaryUnit = new fhirCsR5.Models.CodeableConcept();
          CustomaryUnit.DeserializeJson(ref reader, options);
          break;

        case "decimalPrecision":
          DecimalPrecision = reader.GetInt32();
          break;

        case "_decimalPrecision":
          _DecimalPrecision = new fhirCsR5.Models.Element();
          _DecimalPrecision.DeserializeJson(ref reader, options);
          break;

        case "unit":
          Unit = new fhirCsR5.Models.CodeableConcept();
          Unit.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A set of qualified values associated with a context and a set of conditions -  provides a range for quantitative and ordinal observations and a collection of value sets for qualitative observations.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ObservationDefinitionQualifiedValue>))]
  public class ObservationDefinitionQualifiedValue : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The set of abnormal coded results for qualitative observations  that match the criteria of this set of qualified values.
    /// </summary>
    public string AbnormalCodedValueSet { get; set; }
    /// <summary>
    /// Extension container element for AbnormalCodedValueSet
    /// </summary>
    public Element _AbnormalCodedValueSet { get; set; }
    /// <summary>
    /// Some analytes vary greatly over age.
    /// </summary>
    public Range Age { get; set; }
    /// <summary>
    /// If this element is not present then the global population is assumed.
    /// </summary>
    public List<CodeableConcept> AppliesTo { get; set; }
    /// <summary>
    /// Text based condition for which the the set of qualified values is valid.
    /// </summary>
    public string Condition { get; set; }
    /// <summary>
    /// Extension container element for Condition
    /// </summary>
    public Element _Condition { get; set; }
    /// <summary>
    /// A concept defining the context for this set of qualified values.
    /// </summary>
    public CodeableConcept Context { get; set; }
    /// <summary>
    /// The set of critical coded results for qualitative observations  that match the criteria of this set of qualified values.
    /// </summary>
    public string CriticalCodedValueSet { get; set; }
    /// <summary>
    /// Extension container element for CriticalCodedValueSet
    /// </summary>
    public Element _CriticalCodedValueSet { get; set; }
    /// <summary>
    /// The gender this  set of qualified values applies to.
    /// </summary>
    public string Gender { get; set; }
    /// <summary>
    /// Extension container element for Gender
    /// </summary>
    public Element _Gender { get; set; }
    /// <summary>
    /// The gestational age this  set of qualified values applies to.
    /// </summary>
    public Range GestationalAge { get; set; }
    /// <summary>
    /// The set of normal coded results for qualitative observations  that match the criteria of this set of qualified values.
    /// </summary>
    public string NormalCodedValueSet { get; set; }
    /// <summary>
    /// Extension container element for NormalCodedValueSet
    /// </summary>
    public Element _NormalCodedValueSet { get; set; }
    /// <summary>
    /// The range of values defined for continuous or ordinal observations that match the criteria of this set of qualified values.
    /// </summary>
    public Range Range { get; set; }
    /// <summary>
    /// The category of range of values for continuous or ordinal observations that match the criteria of this set of qualified values.
    /// </summary>
    public string RangeCategory { get; set; }
    /// <summary>
    /// Extension container element for RangeCategory
    /// </summary>
    public Element _RangeCategory { get; set; }
    /// <summary>
    /// The set of valid coded results for qualitative observations  that match the criteria of this set of qualified values.
    /// </summary>
    public string ValidCodedValueSet { get; set; }
    /// <summary>
    /// Extension container element for ValidCodedValueSet
    /// </summary>
    public Element _ValidCodedValueSet { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Context != null)
      {
        writer.WritePropertyName("context");
        Context.SerializeJson(writer, options);
      }

      if ((AppliesTo != null) && (AppliesTo.Count != 0))
      {
        writer.WritePropertyName("appliesTo");
        writer.WriteStartArray();

        foreach (CodeableConcept valAppliesTo in AppliesTo)
        {
          valAppliesTo.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Gender))
      {
        writer.WriteString("gender", (string)Gender!);
      }

      if (_Gender != null)
      {
        writer.WritePropertyName("_gender");
        _Gender.SerializeJson(writer, options);
      }

      if (Age != null)
      {
        writer.WritePropertyName("age");
        Age.SerializeJson(writer, options);
      }

      if (GestationalAge != null)
      {
        writer.WritePropertyName("gestationalAge");
        GestationalAge.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Condition))
      {
        writer.WriteString("condition", (string)Condition!);
      }

      if (_Condition != null)
      {
        writer.WritePropertyName("_condition");
        _Condition.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(RangeCategory))
      {
        writer.WriteString("rangeCategory", (string)RangeCategory!);
      }

      if (_RangeCategory != null)
      {
        writer.WritePropertyName("_rangeCategory");
        _RangeCategory.SerializeJson(writer, options);
      }

      if (Range != null)
      {
        writer.WritePropertyName("range");
        Range.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ValidCodedValueSet))
      {
        writer.WriteString("validCodedValueSet", (string)ValidCodedValueSet!);
      }

      if (_ValidCodedValueSet != null)
      {
        writer.WritePropertyName("_validCodedValueSet");
        _ValidCodedValueSet.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(NormalCodedValueSet))
      {
        writer.WriteString("normalCodedValueSet", (string)NormalCodedValueSet!);
      }

      if (_NormalCodedValueSet != null)
      {
        writer.WritePropertyName("_normalCodedValueSet");
        _NormalCodedValueSet.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(AbnormalCodedValueSet))
      {
        writer.WriteString("abnormalCodedValueSet", (string)AbnormalCodedValueSet!);
      }

      if (_AbnormalCodedValueSet != null)
      {
        writer.WritePropertyName("_abnormalCodedValueSet");
        _AbnormalCodedValueSet.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(CriticalCodedValueSet))
      {
        writer.WriteString("criticalCodedValueSet", (string)CriticalCodedValueSet!);
      }

      if (_CriticalCodedValueSet != null)
      {
        writer.WritePropertyName("_criticalCodedValueSet");
        _CriticalCodedValueSet.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "abnormalCodedValueSet":
          AbnormalCodedValueSet = reader.GetString();
          break;

        case "_abnormalCodedValueSet":
          _AbnormalCodedValueSet = new fhirCsR5.Models.Element();
          _AbnormalCodedValueSet.DeserializeJson(ref reader, options);
          break;

        case "age":
          Age = new fhirCsR5.Models.Range();
          Age.DeserializeJson(ref reader, options);
          break;

        case "appliesTo":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          AppliesTo = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objAppliesTo = new fhirCsR5.Models.CodeableConcept();
            objAppliesTo.DeserializeJson(ref reader, options);
            AppliesTo.Add(objAppliesTo);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (AppliesTo.Count == 0)
          {
            AppliesTo = null;
          }

          break;

        case "condition":
          Condition = reader.GetString();
          break;

        case "_condition":
          _Condition = new fhirCsR5.Models.Element();
          _Condition.DeserializeJson(ref reader, options);
          break;

        case "context":
          Context = new fhirCsR5.Models.CodeableConcept();
          Context.DeserializeJson(ref reader, options);
          break;

        case "criticalCodedValueSet":
          CriticalCodedValueSet = reader.GetString();
          break;

        case "_criticalCodedValueSet":
          _CriticalCodedValueSet = new fhirCsR5.Models.Element();
          _CriticalCodedValueSet.DeserializeJson(ref reader, options);
          break;

        case "gender":
          Gender = reader.GetString();
          break;

        case "_gender":
          _Gender = new fhirCsR5.Models.Element();
          _Gender.DeserializeJson(ref reader, options);
          break;

        case "gestationalAge":
          GestationalAge = new fhirCsR5.Models.Range();
          GestationalAge.DeserializeJson(ref reader, options);
          break;

        case "normalCodedValueSet":
          NormalCodedValueSet = reader.GetString();
          break;

        case "_normalCodedValueSet":
          _NormalCodedValueSet = new fhirCsR5.Models.Element();
          _NormalCodedValueSet.DeserializeJson(ref reader, options);
          break;

        case "range":
          Range = new fhirCsR5.Models.Range();
          Range.DeserializeJson(ref reader, options);
          break;

        case "rangeCategory":
          RangeCategory = reader.GetString();
          break;

        case "_rangeCategory":
          _RangeCategory = new fhirCsR5.Models.Element();
          _RangeCategory.DeserializeJson(ref reader, options);
          break;

        case "validCodedValueSet":
          ValidCodedValueSet = reader.GetString();
          break;

        case "_validCodedValueSet":
          _ValidCodedValueSet = new fhirCsR5.Models.Element();
          _ValidCodedValueSet.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ObservationDefinition.qualifiedValue.gender field
  /// </summary>
  public static class ObservationDefinitionQualifiedValueGenderCodes {
    public const string MALE = "male";
    public const string FEMALE = "female";
    public const string OTHER = "other";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "male",
      "female",
      "other",
      "unknown",
    };
  }
  /// <summary>
  /// Code Values for the ObservationDefinition.qualifiedValue.rangeCategory field
  /// </summary>
  public static class ObservationDefinitionQualifiedValueRangeCategoryCodes {
    public const string REFERENCE = "reference";
    public const string CRITICAL = "critical";
    public const string ABSOLUTE = "absolute";
    public static HashSet<string> Values = new HashSet<string>() {
      "reference",
      "critical",
      "absolute",
    };
  }
  /// <summary>
  /// Some observations have multiple component observations, expressed as separate code value pairs.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ObservationDefinitionComponent>))]
  public class ObservationDefinitionComponent : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Describes what will be observed.
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// The data types allowed for the value element of the instance of this component observations.
    /// </summary>
    public List<string> PermittedDataType { get; set; }
    /// <summary>
    /// Extension container element for PermittedDataType
    /// </summary>
    public List<Element> _PermittedDataType { get; set; }
    /// <summary>
    /// A set of qualified values associated with a context and a set of conditions -  provides a range for quantitative and ordinal observations and a collection of value sets for qualitative observations.
    /// </summary>
    public List<ObservationDefinitionQualifiedValue> QualifiedValue { get; set; }
    /// <summary>
    /// Characteristics for quantitative results of this observation.
    /// </summary>
    public ObservationDefinitionQuantitativeDetails QuantitativeDetails { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if ((PermittedDataType != null) && (PermittedDataType.Count != 0))
      {
        writer.WritePropertyName("permittedDataType");
        writer.WriteStartArray();

        foreach (string valPermittedDataType in PermittedDataType)
        {
          writer.WriteStringValue(valPermittedDataType);
        }

        writer.WriteEndArray();
      }

      if ((_PermittedDataType != null) && (_PermittedDataType.Count != 0))
      {
        writer.WritePropertyName("_permittedDataType");
        writer.WriteStartArray();

        foreach (Element val_PermittedDataType in _PermittedDataType)
        {
          val_PermittedDataType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (QuantitativeDetails != null)
      {
        writer.WritePropertyName("quantitativeDetails");
        QuantitativeDetails.SerializeJson(writer, options);
      }

      if ((QualifiedValue != null) && (QualifiedValue.Count != 0))
      {
        writer.WritePropertyName("qualifiedValue");
        writer.WriteStartArray();

        foreach (ObservationDefinitionQualifiedValue valQualifiedValue in QualifiedValue)
        {
          valQualifiedValue.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = new fhirCsR5.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "permittedDataType":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          PermittedDataType = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            PermittedDataType.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (PermittedDataType.Count == 0)
          {
            PermittedDataType = null;
          }

          break;

        case "_permittedDataType":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _PermittedDataType = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_PermittedDataType = new fhirCsR5.Models.Element();
            obj_PermittedDataType.DeserializeJson(ref reader, options);
            _PermittedDataType.Add(obj_PermittedDataType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_PermittedDataType.Count == 0)
          {
            _PermittedDataType = null;
          }

          break;

        case "qualifiedValue":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          QualifiedValue = new List<ObservationDefinitionQualifiedValue>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ObservationDefinitionQualifiedValue objQualifiedValue = new fhirCsR5.Models.ObservationDefinitionQualifiedValue();
            objQualifiedValue.DeserializeJson(ref reader, options);
            QualifiedValue.Add(objQualifiedValue);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (QualifiedValue.Count == 0)
          {
            QualifiedValue = null;
          }

          break;

        case "quantitativeDetails":
          QuantitativeDetails = new fhirCsR5.Models.ObservationDefinitionQuantitativeDetails();
          QuantitativeDetails.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ObservationDefinition.component.permittedDataType field
  /// </summary>
  public static class ObservationDefinitionComponentPermittedDataTypeCodes {
    public const string QUANTITY = "Quantity";
    public const string CODEABLECONCEPT = "CodeableConcept";
    public const string VAL_STRING = "string";
    public const string BOOLEAN = "boolean";
    public const string INTEGER = "integer";
    public const string RANGE = "Range";
    public const string RATIO = "Ratio";
    public const string SAMPLEDDATA = "SampledData";
    public const string TIME = "time";
    public const string DATETIME = "dateTime";
    public const string PERIOD = "Period";
    public static HashSet<string> Values = new HashSet<string>() {
      "Quantity",
      "CodeableConcept",
      "string",
      "boolean",
      "integer",
      "Range",
      "Ratio",
      "SampledData",
      "time",
      "dateTime",
      "Period",
    };
  }
  /// <summary>
  /// Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ObservationDefinition>))]
  public class ObservationDefinition : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ObservationDefinition";
    /// <summary>
    /// The date may be more recent than the approval date because of minor changes / editorial corrections.
    /// </summary>
    public string ApprovalDate { get; set; }
    /// <summary>
    /// Extension container element for ApprovalDate
    /// </summary>
    public Element _ApprovalDate { get; set; }
    /// <summary>
    /// Only used if the defined observation is to be made directly on a body part and if this body part is not implied by code found in ObservationDefinition.code. Not used for in vitro diagnostic observations. 
    /// Example: 14975008 |Forearm structure|.
    /// </summary>
    public CodeableConcept BodySite { get; set; }
    /// <summary>
    /// This element allows various categorization schemes based on the owner’s definition of the category and effectively multiple categories can be used for one instance of ObservationDefinition. The level of granularity is defined by the category concepts in the value set.
    /// </summary>
    public List<CodeableConcept> Category { get; set; }
    /// <summary>
    /// Describes what will be observed. Sometimes this is called the observation "name".
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// Some observations have multiple component observations, expressed as separate code value pairs.
    /// </summary>
    public List<ObservationDefinitionComponent> Component { get; set; }
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// Copyright statement relating to the ObservationDefinition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the ObservationDefinition.
    /// </summary>
    public string Copyright { get; set; }
    /// <summary>
    /// Extension container element for Copyright
    /// </summary>
    public Element _Copyright { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the ObservationDefinition. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// The canonical URL pointing to another FHIR-defined ObservationDefinition that is adhered to in whole or in part by this definition.
    /// </summary>
    public List<string> DerivedFromCanonical { get; set; }
    /// <summary>
    /// Extension container element for DerivedFromCanonical
    /// </summary>
    public List<Element> _DerivedFromCanonical { get; set; }
    /// <summary>
    /// The URL pointing to an externally-defined observation definition, guideline or other definition that is adhered to in whole or in part by this definition.
    /// </summary>
    public List<string> DerivedFromUri { get; set; }
    /// <summary>
    /// Extension container element for DerivedFromUri
    /// </summary>
    public List<Element> _DerivedFromUri { get; set; }
    /// <summary>
    /// This description can be used to capture details such as why the ObservationDefinition was built, comments about misuse, instructions for clinical use and interpretation, literature references, examples from the paper world, etc. It is not a rendering of the module as conveyed in the text field of the resource itself. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// When multiple occurrences of device are present, they are to be combined with a logical OR: at least one of the specified devices is used to produce the observation.
    /// </summary>
    public List<Reference> Device { get; set; }
    /// <summary>
    /// The effective period for an ObservationDefinition determines when the content is applicable for usage and is independent of publication and review dates. For example, an observation intended to be used for the year 2021 might be published in 2020.
    /// </summary>
    public Period EffectivePeriod { get; set; }
    /// <summary>
    /// Allows filtering of ObservationDefinition that are appropriate for use vs. not.
    /// </summary>
    public bool? Experimental { get; set; }
    /// <summary>
    /// Extension container element for Experimental
    /// </summary>
    public Element _Experimental { get; set; }
    /// <summary>
    /// This ObservationDefinition defines a group  observation (e.g. a battery, a panel of tests, a set of vital sign measurements) that includes the target as a member of the group.
    /// </summary>
    public List<Reference> HasMember { get; set; }
    /// <summary>
    /// This is a business identifier, not a resource identifier. It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.
    /// </summary>
    public Identifier Identifier { get; set; }
    /// <summary>
    /// It may be possible for the ObservationDefinition to be used in jurisdictions other than those for which it was originally designed or intended.
    /// </summary>
    public List<CodeableConcept> Jurisdiction { get; set; }
    /// <summary>
    /// If specified, this is usually after the approval date.
    /// </summary>
    public string LastReviewDate { get; set; }
    /// <summary>
    /// Extension container element for LastReviewDate
    /// </summary>
    public Element _LastReviewDate { get; set; }
    /// <summary>
    /// Only used if not implicit in observation code
    /// Example: 702659008 |Automated count technique|.
    /// </summary>
    public CodeableConcept Method { get; set; }
    /// <summary>
    /// An example of observation allowing multiple results is "bacteria identified by culture". Conversely, the measurement of a potassium level allows a single result.
    /// </summary>
    public bool? MultipleResultsAllowed { get; set; }
    /// <summary>
    /// Extension container element for MultipleResultsAllowed
    /// </summary>
    public Element _MultipleResultsAllowed { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// The type of individual/organization/device that is expected to act upon instances of this definition.
    /// </summary>
    public CodeableConcept PerformerType { get; set; }
    /// <summary>
    /// The data types allowed for the value element of the instance observations conforming to this ObservationDefinition.
    /// </summary>
    public List<string> PermittedDataType { get; set; }
    /// <summary>
    /// Extension container element for PermittedDataType
    /// </summary>
    public List<Element> _PermittedDataType { get; set; }
    /// <summary>
    /// The preferred name to be used when reporting the results of observations conforming to this ObservationDefinition.
    /// </summary>
    public string PreferredReportName { get; set; }
    /// <summary>
    /// Extension container element for PreferredReportName
    /// </summary>
    public Element _PreferredReportName { get; set; }
    /// <summary>
    /// Helps establish the "authority/credibility" of the ObservationDefinition. May also allow for contact.
    /// </summary>
    public Reference Publisher { get; set; }
    /// <summary>
    /// This element does not describe the usage of the ObservationDefinition. Rather it is for traceability of ''why'' the resource is either needed or ''why'' it is defined as it is. This may be used to point to source materials or specifications that drove the structure of this ObservationDefinition.
    /// </summary>
    public string Purpose { get; set; }
    /// <summary>
    /// Extension container element for Purpose
    /// </summary>
    public Element _Purpose { get; set; }
    /// <summary>
    /// A set of qualified values associated with a context and a set of conditions -  provides a range for quantitative and ordinal observations and a collection of value sets for qualitative observations.
    /// </summary>
    public List<ObservationDefinitionQualifiedValue> QualifiedValue { get; set; }
    /// <summary>
    /// Characteristics for quantitative results of observations conforming to this ObservationDefinition.
    /// </summary>
    public ObservationDefinitionQuantitativeDetails QuantitativeDetails { get; set; }
    /// <summary>
    /// Only used for in vitro observations. When multiple occurrences of specimen are present, they are to be combined with a logical AND: all specified specimens  are needed for the observation.
    /// </summary>
    public List<Reference> Specimen { get; set; }
    /// <summary>
    /// A nominal state-transition diagram can be found in the [[definition.html#statemachine | Definition pattern]] documentation
    /// Unknown does not represent "other" - one of the defined statuses must apply. Unknown is used when the authoring system is not sure what the current status is.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Examples: person, animal, device, air, surface ….
    /// </summary>
    public List<CodeableConcept> Subject { get; set; }
    /// <summary>
    /// A short, descriptive, user-friendly title for the ObservationDefinition.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid:, but real http: addresses are preferred. This is the URI that will be used when making canonical references to this resource.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple usageContexts are specified, there is no expectation for whether all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// There may be multiple different instances of a ObservationDefinition that have the same identifier but different versions.
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (Identifier != null)
      {
        writer.WritePropertyName("identifier");
        Identifier.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Version))
      {
        writer.WriteString("version", (string)Version!);
      }

      if (_Version != null)
      {
        writer.WritePropertyName("_version");
        _Version.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Experimental != null)
      {
        writer.WriteBoolean("experimental", (bool)Experimental!);
      }

      if (_Experimental != null)
      {
        writer.WritePropertyName("_experimental");
        _Experimental.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (Publisher != null)
      {
        writer.WritePropertyName("publisher");
        Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Jurisdiction != null) && (Jurisdiction.Count != 0))
      {
        writer.WritePropertyName("jurisdiction");
        writer.WriteStartArray();

        foreach (CodeableConcept valJurisdiction in Jurisdiction)
        {
          valJurisdiction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Purpose))
      {
        writer.WriteString("purpose", (string)Purpose!);
      }

      if (_Purpose != null)
      {
        writer.WritePropertyName("_purpose");
        _Purpose.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Copyright))
      {
        writer.WriteString("copyright", (string)Copyright!);
      }

      if (_Copyright != null)
      {
        writer.WritePropertyName("_copyright");
        _Copyright.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ApprovalDate))
      {
        writer.WriteString("approvalDate", (string)ApprovalDate!);
      }

      if (_ApprovalDate != null)
      {
        writer.WritePropertyName("_approvalDate");
        _ApprovalDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(LastReviewDate))
      {
        writer.WriteString("lastReviewDate", (string)LastReviewDate!);
      }

      if (_LastReviewDate != null)
      {
        writer.WritePropertyName("_lastReviewDate");
        _LastReviewDate.SerializeJson(writer, options);
      }

      if (EffectivePeriod != null)
      {
        writer.WritePropertyName("effectivePeriod");
        EffectivePeriod.SerializeJson(writer, options);
      }

      if ((DerivedFromCanonical != null) && (DerivedFromCanonical.Count != 0))
      {
        writer.WritePropertyName("derivedFromCanonical");
        writer.WriteStartArray();

        foreach (string valDerivedFromCanonical in DerivedFromCanonical)
        {
          writer.WriteStringValue(valDerivedFromCanonical);
        }

        writer.WriteEndArray();
      }

      if ((_DerivedFromCanonical != null) && (_DerivedFromCanonical.Count != 0))
      {
        writer.WritePropertyName("_derivedFromCanonical");
        writer.WriteStartArray();

        foreach (Element val_DerivedFromCanonical in _DerivedFromCanonical)
        {
          val_DerivedFromCanonical.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((DerivedFromUri != null) && (DerivedFromUri.Count != 0))
      {
        writer.WritePropertyName("derivedFromUri");
        writer.WriteStartArray();

        foreach (string valDerivedFromUri in DerivedFromUri)
        {
          writer.WriteStringValue(valDerivedFromUri);
        }

        writer.WriteEndArray();
      }

      if ((_DerivedFromUri != null) && (_DerivedFromUri.Count != 0))
      {
        writer.WritePropertyName("_derivedFromUri");
        writer.WriteStartArray();

        foreach (Element val_DerivedFromUri in _DerivedFromUri)
        {
          val_DerivedFromUri.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Subject != null) && (Subject.Count != 0))
      {
        writer.WritePropertyName("subject");
        writer.WriteStartArray();

        foreach (CodeableConcept valSubject in Subject)
        {
          valSubject.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (PerformerType != null)
      {
        writer.WritePropertyName("performerType");
        PerformerType.SerializeJson(writer, options);
      }

      if ((Category != null) && (Category.Count != 0))
      {
        writer.WritePropertyName("category");
        writer.WriteStartArray();

        foreach (CodeableConcept valCategory in Category)
        {
          valCategory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(writer, options);
      }

      if ((PermittedDataType != null) && (PermittedDataType.Count != 0))
      {
        writer.WritePropertyName("permittedDataType");
        writer.WriteStartArray();

        foreach (string valPermittedDataType in PermittedDataType)
        {
          writer.WriteStringValue(valPermittedDataType);
        }

        writer.WriteEndArray();
      }

      if ((_PermittedDataType != null) && (_PermittedDataType.Count != 0))
      {
        writer.WritePropertyName("_permittedDataType");
        writer.WriteStartArray();

        foreach (Element val_PermittedDataType in _PermittedDataType)
        {
          val_PermittedDataType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (MultipleResultsAllowed != null)
      {
        writer.WriteBoolean("multipleResultsAllowed", (bool)MultipleResultsAllowed!);
      }

      if (_MultipleResultsAllowed != null)
      {
        writer.WritePropertyName("_multipleResultsAllowed");
        _MultipleResultsAllowed.SerializeJson(writer, options);
      }

      if (BodySite != null)
      {
        writer.WritePropertyName("bodySite");
        BodySite.SerializeJson(writer, options);
      }

      if (Method != null)
      {
        writer.WritePropertyName("method");
        Method.SerializeJson(writer, options);
      }

      if ((Specimen != null) && (Specimen.Count != 0))
      {
        writer.WritePropertyName("specimen");
        writer.WriteStartArray();

        foreach (Reference valSpecimen in Specimen)
        {
          valSpecimen.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Device != null) && (Device.Count != 0))
      {
        writer.WritePropertyName("device");
        writer.WriteStartArray();

        foreach (Reference valDevice in Device)
        {
          valDevice.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(PreferredReportName))
      {
        writer.WriteString("preferredReportName", (string)PreferredReportName!);
      }

      if (_PreferredReportName != null)
      {
        writer.WritePropertyName("_preferredReportName");
        _PreferredReportName.SerializeJson(writer, options);
      }

      if (QuantitativeDetails != null)
      {
        writer.WritePropertyName("quantitativeDetails");
        QuantitativeDetails.SerializeJson(writer, options);
      }

      if ((QualifiedValue != null) && (QualifiedValue.Count != 0))
      {
        writer.WritePropertyName("qualifiedValue");
        writer.WriteStartArray();

        foreach (ObservationDefinitionQualifiedValue valQualifiedValue in QualifiedValue)
        {
          valQualifiedValue.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((HasMember != null) && (HasMember.Count != 0))
      {
        writer.WritePropertyName("hasMember");
        writer.WriteStartArray();

        foreach (Reference valHasMember in HasMember)
        {
          valHasMember.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Component != null) && (Component.Count != 0))
      {
        writer.WritePropertyName("component");
        writer.WriteStartArray();

        foreach (ObservationDefinitionComponent valComponent in Component)
        {
          valComponent.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "approvalDate":
          ApprovalDate = reader.GetString();
          break;

        case "_approvalDate":
          _ApprovalDate = new fhirCsR5.Models.Element();
          _ApprovalDate.DeserializeJson(ref reader, options);
          break;

        case "bodySite":
          BodySite = new fhirCsR5.Models.CodeableConcept();
          BodySite.DeserializeJson(ref reader, options);
          break;

        case "category":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Category = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objCategory = new fhirCsR5.Models.CodeableConcept();
            objCategory.DeserializeJson(ref reader, options);
            Category.Add(objCategory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Category.Count == 0)
          {
            Category = null;
          }

          break;

        case "code":
          Code = new fhirCsR5.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "component":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Component = new List<ObservationDefinitionComponent>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ObservationDefinitionComponent objComponent = new fhirCsR5.Models.ObservationDefinitionComponent();
            objComponent.DeserializeJson(ref reader, options);
            Component.Add(objComponent);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Component.Count == 0)
          {
            Component = null;
          }

          break;

        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ContactDetail objContact = new fhirCsR5.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "copyright":
          Copyright = reader.GetString();
          break;

        case "_copyright":
          _Copyright = new fhirCsR5.Models.Element();
          _Copyright.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR5.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "derivedFromCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DerivedFromCanonical = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            DerivedFromCanonical.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DerivedFromCanonical.Count == 0)
          {
            DerivedFromCanonical = null;
          }

          break;

        case "_derivedFromCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _DerivedFromCanonical = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_DerivedFromCanonical = new fhirCsR5.Models.Element();
            obj_DerivedFromCanonical.DeserializeJson(ref reader, options);
            _DerivedFromCanonical.Add(obj_DerivedFromCanonical);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_DerivedFromCanonical.Count == 0)
          {
            _DerivedFromCanonical = null;
          }

          break;

        case "derivedFromUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DerivedFromUri = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            DerivedFromUri.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DerivedFromUri.Count == 0)
          {
            DerivedFromUri = null;
          }

          break;

        case "_derivedFromUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _DerivedFromUri = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_DerivedFromUri = new fhirCsR5.Models.Element();
            obj_DerivedFromUri.DeserializeJson(ref reader, options);
            _DerivedFromUri.Add(obj_DerivedFromUri);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_DerivedFromUri.Count == 0)
          {
            _DerivedFromUri = null;
          }

          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR5.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "device":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Device = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objDevice = new fhirCsR5.Models.Reference();
            objDevice.DeserializeJson(ref reader, options);
            Device.Add(objDevice);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Device.Count == 0)
          {
            Device = null;
          }

          break;

        case "effectivePeriod":
          EffectivePeriod = new fhirCsR5.Models.Period();
          EffectivePeriod.DeserializeJson(ref reader, options);
          break;

        case "experimental":
          Experimental = reader.GetBoolean();
          break;

        case "_experimental":
          _Experimental = new fhirCsR5.Models.Element();
          _Experimental.DeserializeJson(ref reader, options);
          break;

        case "hasMember":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          HasMember = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objHasMember = new fhirCsR5.Models.Reference();
            objHasMember.DeserializeJson(ref reader, options);
            HasMember.Add(objHasMember);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (HasMember.Count == 0)
          {
            HasMember = null;
          }

          break;

        case "identifier":
          Identifier = new fhirCsR5.Models.Identifier();
          Identifier.DeserializeJson(ref reader, options);
          break;

        case "jurisdiction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Jurisdiction = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objJurisdiction = new fhirCsR5.Models.CodeableConcept();
            objJurisdiction.DeserializeJson(ref reader, options);
            Jurisdiction.Add(objJurisdiction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Jurisdiction.Count == 0)
          {
            Jurisdiction = null;
          }

          break;

        case "lastReviewDate":
          LastReviewDate = reader.GetString();
          break;

        case "_lastReviewDate":
          _LastReviewDate = new fhirCsR5.Models.Element();
          _LastReviewDate.DeserializeJson(ref reader, options);
          break;

        case "method":
          Method = new fhirCsR5.Models.CodeableConcept();
          Method.DeserializeJson(ref reader, options);
          break;

        case "multipleResultsAllowed":
          MultipleResultsAllowed = reader.GetBoolean();
          break;

        case "_multipleResultsAllowed":
          _MultipleResultsAllowed = new fhirCsR5.Models.Element();
          _MultipleResultsAllowed.DeserializeJson(ref reader, options);
          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR5.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "performerType":
          PerformerType = new fhirCsR5.Models.CodeableConcept();
          PerformerType.DeserializeJson(ref reader, options);
          break;

        case "permittedDataType":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          PermittedDataType = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            PermittedDataType.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (PermittedDataType.Count == 0)
          {
            PermittedDataType = null;
          }

          break;

        case "_permittedDataType":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _PermittedDataType = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_PermittedDataType = new fhirCsR5.Models.Element();
            obj_PermittedDataType.DeserializeJson(ref reader, options);
            _PermittedDataType.Add(obj_PermittedDataType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_PermittedDataType.Count == 0)
          {
            _PermittedDataType = null;
          }

          break;

        case "preferredReportName":
          PreferredReportName = reader.GetString();
          break;

        case "_preferredReportName":
          _PreferredReportName = new fhirCsR5.Models.Element();
          _PreferredReportName.DeserializeJson(ref reader, options);
          break;

        case "publisher":
          Publisher = new fhirCsR5.Models.Reference();
          Publisher.DeserializeJson(ref reader, options);
          break;

        case "purpose":
          Purpose = reader.GetString();
          break;

        case "_purpose":
          _Purpose = new fhirCsR5.Models.Element();
          _Purpose.DeserializeJson(ref reader, options);
          break;

        case "qualifiedValue":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          QualifiedValue = new List<ObservationDefinitionQualifiedValue>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ObservationDefinitionQualifiedValue objQualifiedValue = new fhirCsR5.Models.ObservationDefinitionQualifiedValue();
            objQualifiedValue.DeserializeJson(ref reader, options);
            QualifiedValue.Add(objQualifiedValue);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (QualifiedValue.Count == 0)
          {
            QualifiedValue = null;
          }

          break;

        case "quantitativeDetails":
          QuantitativeDetails = new fhirCsR5.Models.ObservationDefinitionQuantitativeDetails();
          QuantitativeDetails.DeserializeJson(ref reader, options);
          break;

        case "specimen":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Specimen = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objSpecimen = new fhirCsR5.Models.Reference();
            objSpecimen.DeserializeJson(ref reader, options);
            Specimen.Add(objSpecimen);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Specimen.Count == 0)
          {
            Specimen = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Subject = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objSubject = new fhirCsR5.Models.CodeableConcept();
            objSubject.DeserializeJson(ref reader, options);
            Subject.Add(objSubject);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Subject.Count == 0)
          {
            Subject = null;
          }

          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR5.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR5.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.UsageContext objUseContext = new fhirCsR5.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new fhirCsR5.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ObservationDefinition.permittedDataType field
  /// </summary>
  public static class ObservationDefinitionPermittedDataTypeCodes {
    public const string QUANTITY = "Quantity";
    public const string CODEABLECONCEPT = "CodeableConcept";
    public const string VAL_STRING = "string";
    public const string BOOLEAN = "boolean";
    public const string INTEGER = "integer";
    public const string RANGE = "Range";
    public const string RATIO = "Ratio";
    public const string SAMPLEDDATA = "SampledData";
    public const string TIME = "time";
    public const string DATETIME = "dateTime";
    public const string PERIOD = "Period";
    public static HashSet<string> Values = new HashSet<string>() {
      "Quantity",
      "CodeableConcept",
      "string",
      "boolean",
      "integer",
      "Range",
      "Ratio",
      "SampledData",
      "time",
      "dateTime",
      "Period",
    };
  }
  /// <summary>
  /// Code Values for the ObservationDefinition.status field
  /// </summary>
  public static class ObservationDefinitionStatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "draft",
      "active",
      "retired",
      "unknown",
    };
  }
}
