// <auto-generated />
// Built from: hl7.fhir.r5.core version: 5.0.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// The current status is always found in the current version of the resource, not the status history.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterStatusHistory>))]
  public class EncounterStatusHistory : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The time that the episode was in the specified status.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// planned | in-progress | onhold | completed | cancelled | entered-in-error | unknown.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "period":
          Period = new fhirCsR5.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Encounter.statusHistory.status field
  /// </summary>
  public static class EncounterStatusHistoryStatusCodes {
    public const string PLANNED = "planned";
    public const string IN_PROGRESS = "in-progress";
    public const string ONHOLD = "onhold";
    public const string COMPLETED = "completed";
    public const string CANCELLED = "cancelled";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "planned",
      "in-progress",
      "onhold",
      "completed",
      "cancelled",
      "entered-in-error",
      "unknown",
    };
  }
  /// <summary>
  /// The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterClassHistory>))]
  public class EncounterClassHistory : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// inpatient | outpatient | ambulatory | emergency +.
    /// </summary>
    public Coding Class { get; set; }
    /// <summary>
    /// The time that the episode was in the specified class.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Class != null)
      {
        writer.WritePropertyName("class");
        Class.SerializeJson(writer, options);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "class":
          Class = new fhirCsR5.Models.Coding();
          Class.DeserializeJson(ref reader, options);
          break;

        case "period":
          Period = new fhirCsR5.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The list of people responsible for providing the service.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterParticipant>))]
  public class EncounterParticipant : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Persons involved in the encounter, the patient/group is also included here to indicate that the patient was actually participating in the encounter. Not including the patient here covers use cases such as a case meeting between practitioners about a patient - non contact times.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// The participant type indicates how an individual actor participates in an encounter. It includes non-practitioner participants, and for practitioners this is to describe the action type in the context of this encounter (e.g. Admitting Dr, Attending Dr, Translator, Consulting Dr). This is different to the practitioner roles which are functional roles, derived from terms of employment, education, licensing, etc.
    /// </summary>
    public List<CodeableConcept> Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if ((Type != null) && (Type.Count != 0))
      {
        writer.WritePropertyName("type");
        writer.WriteStartArray();

        foreach (CodeableConcept valType in Type)
        {
          valType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (Actor != null)
      {
        writer.WritePropertyName("actor");
        Actor.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new fhirCsR5.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "period":
          Period = new fhirCsR5.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        case "type":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Type = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objType = new fhirCsR5.Models.CodeableConcept();
            objType.DeserializeJson(ref reader, options);
            Type.Add(objType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Type.Count == 0)
          {
            Type = null;
          }

          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The list of diagnosis relevant to this encounter.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterDiagnosis>))]
  public class EncounterDiagnosis : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// For systems that need to know which was the primary diagnosis, these will be marked with the standard extension primaryDiagnosis (which is a sequence value rather than a flag, 1 = primary diagnosis).
    /// </summary>
    public Reference Condition { get; set; }
    /// <summary>
    /// Ranking of the diagnosis (for each role type).
    /// </summary>
    public uint? Rank { get; set; }
    /// <summary>
    /// Role that this diagnosis has within the encounter (e.g. admission, billing, discharge â€¦).
    /// </summary>
    public CodeableConcept Use { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Condition != null)
      {
        writer.WritePropertyName("condition");
        Condition.SerializeJson(writer, options);
      }

      if (Use != null)
      {
        writer.WritePropertyName("use");
        Use.SerializeJson(writer, options);
      }

      if (Rank != null)
      {
        writer.WriteNumber("rank", (uint)Rank!);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "condition":
          Condition = new fhirCsR5.Models.Reference();
          Condition.DeserializeJson(ref reader, options);
          break;

        case "rank":
          Rank = reader.GetUInt32();
          break;

        case "use":
          Use = new fhirCsR5.Models.CodeableConcept();
          Use.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// An Encounter may cover more than just the inpatient stay. Contexts such as outpatients, community clinics, and aged care facilities are also included.
  /// The duration recorded in the period of this encounter covers the entire scope of this hospitalization record.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterHospitalization>))]
  public class EncounterHospitalization : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// From where patient was admitted (physician referral, transfer).
    /// </summary>
    public CodeableConcept AdmitSource { get; set; }
    /// <summary>
    /// Location/organization to which the patient is discharged.
    /// </summary>
    public Reference Destination { get; set; }
    /// <summary>
    /// For example, a patient may request both a dairy-free and nut-free diet preference (not mutually exclusive).
    /// </summary>
    public List<CodeableConcept> DietPreference { get; set; }
    /// <summary>
    /// Category or kind of location after discharge.
    /// </summary>
    public CodeableConcept DischargeDisposition { get; set; }
    /// <summary>
    /// The location/organization from which the patient came before admission.
    /// </summary>
    public Reference Origin { get; set; }
    /// <summary>
    /// Pre-admission identifier.
    /// </summary>
    public Identifier PreAdmissionIdentifier { get; set; }
    /// <summary>
    /// Whether this hospitalization is a readmission and why if known.
    /// </summary>
    public CodeableConcept ReAdmission { get; set; }
    /// <summary>
    /// Any special requests that have been made for this hospitalization encounter, such as the provision of specific equipment or other things.
    /// </summary>
    public List<CodeableConcept> SpecialArrangement { get; set; }
    /// <summary>
    /// Special courtesies (VIP, board member).
    /// </summary>
    public List<CodeableConcept> SpecialCourtesy { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (PreAdmissionIdentifier != null)
      {
        writer.WritePropertyName("preAdmissionIdentifier");
        PreAdmissionIdentifier.SerializeJson(writer, options);
      }

      if (Origin != null)
      {
        writer.WritePropertyName("origin");
        Origin.SerializeJson(writer, options);
      }

      if (AdmitSource != null)
      {
        writer.WritePropertyName("admitSource");
        AdmitSource.SerializeJson(writer, options);
      }

      if (ReAdmission != null)
      {
        writer.WritePropertyName("reAdmission");
        ReAdmission.SerializeJson(writer, options);
      }

      if ((DietPreference != null) && (DietPreference.Count != 0))
      {
        writer.WritePropertyName("dietPreference");
        writer.WriteStartArray();

        foreach (CodeableConcept valDietPreference in DietPreference)
        {
          valDietPreference.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((SpecialCourtesy != null) && (SpecialCourtesy.Count != 0))
      {
        writer.WritePropertyName("specialCourtesy");
        writer.WriteStartArray();

        foreach (CodeableConcept valSpecialCourtesy in SpecialCourtesy)
        {
          valSpecialCourtesy.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((SpecialArrangement != null) && (SpecialArrangement.Count != 0))
      {
        writer.WritePropertyName("specialArrangement");
        writer.WriteStartArray();

        foreach (CodeableConcept valSpecialArrangement in SpecialArrangement)
        {
          valSpecialArrangement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Destination != null)
      {
        writer.WritePropertyName("destination");
        Destination.SerializeJson(writer, options);
      }

      if (DischargeDisposition != null)
      {
        writer.WritePropertyName("dischargeDisposition");
        DischargeDisposition.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "admitSource":
          AdmitSource = new fhirCsR5.Models.CodeableConcept();
          AdmitSource.DeserializeJson(ref reader, options);
          break;

        case "destination":
          Destination = new fhirCsR5.Models.Reference();
          Destination.DeserializeJson(ref reader, options);
          break;

        case "dietPreference":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DietPreference = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objDietPreference = new fhirCsR5.Models.CodeableConcept();
            objDietPreference.DeserializeJson(ref reader, options);
            DietPreference.Add(objDietPreference);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DietPreference.Count == 0)
          {
            DietPreference = null;
          }

          break;

        case "dischargeDisposition":
          DischargeDisposition = new fhirCsR5.Models.CodeableConcept();
          DischargeDisposition.DeserializeJson(ref reader, options);
          break;

        case "origin":
          Origin = new fhirCsR5.Models.Reference();
          Origin.DeserializeJson(ref reader, options);
          break;

        case "preAdmissionIdentifier":
          PreAdmissionIdentifier = new fhirCsR5.Models.Identifier();
          PreAdmissionIdentifier.DeserializeJson(ref reader, options);
          break;

        case "reAdmission":
          ReAdmission = new fhirCsR5.Models.CodeableConcept();
          ReAdmission.DeserializeJson(ref reader, options);
          break;

        case "specialArrangement":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SpecialArrangement = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objSpecialArrangement = new fhirCsR5.Models.CodeableConcept();
            objSpecialArrangement.DeserializeJson(ref reader, options);
            SpecialArrangement.Add(objSpecialArrangement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SpecialArrangement.Count == 0)
          {
            SpecialArrangement = null;
          }

          break;

        case "specialCourtesy":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SpecialCourtesy = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objSpecialCourtesy = new fhirCsR5.Models.CodeableConcept();
            objSpecialCourtesy.DeserializeJson(ref reader, options);
            SpecialCourtesy.Add(objSpecialCourtesy);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SpecialCourtesy.Count == 0)
          {
            SpecialCourtesy = null;
          }

          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Virtual encounters can be recorded in the Encounter by specifying a location reference to a location of type "kind" such as "client's home" and an encounter.class = "virtual".
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<EncounterLocation>))]
  public class EncounterLocation : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The location where the encounter takes place.
    /// </summary>
    public Reference Location { get; set; }
    /// <summary>
    /// Time period during which the patient was present at the location.
    /// </summary>
    public Period Period { get; set; }
    /// <summary>
    /// This information is de-normalized from the Location resource to support the easier understanding of the encounter resource and processing in messaging or query.
    /// There may be many levels in the hierachy, and this may only pic specific levels that are required for a specific usage scenario.
    /// </summary>
    public CodeableConcept PhysicalType { get; set; }
    /// <summary>
    /// When the patient is no longer active at a location, then the period end date is entered, and the status may be changed to completed.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (PhysicalType != null)
      {
        writer.WritePropertyName("physicalType");
        PhysicalType.SerializeJson(writer, options);
      }

      if (Period != null)
      {
        writer.WritePropertyName("period");
        Period.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "location":
          Location = new fhirCsR5.Models.Reference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "period":
          Period = new fhirCsR5.Models.Period();
          Period.DeserializeJson(ref reader, options);
          break;

        case "physicalType":
          PhysicalType = new fhirCsR5.Models.CodeableConcept();
          PhysicalType.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Encounter.location.status field
  /// </summary>
  public static class EncounterLocationStatusCodes {
    public const string PLANNED = "planned";
    public const string ACTIVE = "active";
    public const string RESERVED = "reserved";
    public const string COMPLETED = "completed";
    public static HashSet<string> Values = new HashSet<string>() {
      "planned",
      "active",
      "reserved",
      "completed",
    };
  }
  /// <summary>
  /// An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<Encounter>))]
  public class Encounter : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Encounter";
    /// <summary>
    /// The billing system may choose to allocate billable items associated with the Encounter to different referenced Accounts based on internal business rules.
    /// </summary>
    public List<Reference> Account { get; set; }
    /// <summary>
    /// If not (yet) known, the end of the Period may be omitted.
    /// </summary>
    public Period ActualPeriod { get; set; }
    /// <summary>
    /// The appointment that scheduled this encounter.
    /// </summary>
    public List<Reference> Appointment { get; set; }
    /// <summary>
    /// The request this encounter satisfies (e.g. incoming referral or procedure request).
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations.
    /// </summary>
    public Coding Class { get; set; }
    /// <summary>
    /// The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
    /// </summary>
    public List<EncounterClassHistory> ClassHistory { get; set; }
    /// <summary>
    /// The list of diagnosis relevant to this encounter.
    /// </summary>
    public List<EncounterDiagnosis> Diagnosis { get; set; }
    /// <summary>
    /// Where a specific encounter should be classified as a part of a specific episode(s) of care this field should be used. This association can facilitate grouping of related encounters together for a specific purpose, such as government reporting, issue tracking, association via a common problem.  The association is recorded on the encounter as these are typically created after the episode of care and grouped on entry rather than editing the episode of care to append another encounter to it (the episode of care could span years).
    /// </summary>
    public List<Reference> EpisodeOfCare { get; set; }
    /// <summary>
    /// An Encounter may cover more than just the inpatient stay. Contexts such as outpatients, community clinics, and aged care facilities are also included.
    /// The duration recorded in the period of this encounter covers the entire scope of this hospitalization record.
    /// </summary>
    public EncounterHospitalization Hospitalization { get; set; }
    /// <summary>
    /// Identifier(s) by which this encounter is known.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// May differ from the time the Encounter.period lasted because of leave of absence.
    /// </summary>
    public Duration Length { get; set; }
    /// <summary>
    /// Virtual encounters can be recorded in the Encounter by specifying a location reference to a location of type "kind" such as "client's home" and an encounter.class = "virtual".
    /// </summary>
    public List<EncounterLocation> Location { get; set; }
    /// <summary>
    /// The list of people responsible for providing the service.
    /// </summary>
    public List<EncounterParticipant> Participant { get; set; }
    /// <summary>
    /// This is also used for associating a child's encounter back to the mother's encounter.
    /// Refer to the Notes section in the Patient resource for further details.
    /// </summary>
    public Reference PartOf { get; set; }
    /// <summary>
    /// The planned end date/time (or discharge date) of the encounter.
    /// </summary>
    public string PlannedEndDate { get; set; }
    /// <summary>
    /// Extension container element for PlannedEndDate
    /// </summary>
    public Element _PlannedEndDate { get; set; }
    /// <summary>
    /// The planned start date/time (or admission date) of the encounter.
    /// </summary>
    public string PlannedStartDate { get; set; }
    /// <summary>
    /// Extension container element for PlannedStartDate
    /// </summary>
    public Element _PlannedStartDate { get; set; }
    /// <summary>
    /// Indicates the urgency of the encounter.
    /// </summary>
    public CodeableConcept Priority { get; set; }
    /// <summary>
    /// For systems that need to know which was the primary diagnosis, these will be marked with the standard extension primaryDiagnosis (which is a sequence value rather than a flag, 1 = primary diagnosis).
    /// </summary>
    public List<CodeableReference> Reason { get; set; }
    /// <summary>
    /// The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
    /// </summary>
    public Reference ServiceProvider { get; set; }
    /// <summary>
    /// Broad categorization of the service that is to be provided (e.g. cardiology).
    /// </summary>
    public CodeableConcept ServiceType { get; set; }
    /// <summary>
    /// Note that internal business rules will determine the appropriate transitions that may occur between statuses (and also classes).
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// The current status is always found in the current version of the resource, not the status history.
    /// </summary>
    public List<EncounterStatusHistory> StatusHistory { get; set; }
    /// <summary>
    /// While the encounter is always about the patient, the patient might not actually be known in all contexts of use, and there may be a group of patients that could be anonymous (such as in a group therapy for Alcoholics Anonymous - where the recording of the encounter could be used for billing on the number of people/staff and not important to the context of the specific patients) or alternately in veterinary care a herd of sheep receiving treatment (where the animals are not individually tracked).
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// The subjectStatus value can be used to track the patient's status within the encounter. It details whether the patient has arrived or departed, has been triaged or is currently in a waiting status.
    /// </summary>
    public CodeableConcept SubjectStatus { get; set; }
    /// <summary>
    /// Since there are many ways to further classify encounters, this element is 0..*.
    /// </summary>
    public List<CodeableConcept> Type { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if ((StatusHistory != null) && (StatusHistory.Count != 0))
      {
        writer.WritePropertyName("statusHistory");
        writer.WriteStartArray();

        foreach (EncounterStatusHistory valStatusHistory in StatusHistory)
        {
          valStatusHistory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Class != null)
      {
        writer.WritePropertyName("class");
        Class.SerializeJson(writer, options);
      }

      if ((ClassHistory != null) && (ClassHistory.Count != 0))
      {
        writer.WritePropertyName("classHistory");
        writer.WriteStartArray();

        foreach (EncounterClassHistory valClassHistory in ClassHistory)
        {
          valClassHistory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Type != null) && (Type.Count != 0))
      {
        writer.WritePropertyName("type");
        writer.WriteStartArray();

        foreach (CodeableConcept valType in Type)
        {
          valType.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ServiceType != null)
      {
        writer.WritePropertyName("serviceType");
        ServiceType.SerializeJson(writer, options);
      }

      if (Priority != null)
      {
        writer.WritePropertyName("priority");
        Priority.SerializeJson(writer, options);
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if (SubjectStatus != null)
      {
        writer.WritePropertyName("subjectStatus");
        SubjectStatus.SerializeJson(writer, options);
      }

      if ((EpisodeOfCare != null) && (EpisodeOfCare.Count != 0))
      {
        writer.WritePropertyName("episodeOfCare");
        writer.WriteStartArray();

        foreach (Reference valEpisodeOfCare in EpisodeOfCare)
        {
          valEpisodeOfCare.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Participant != null) && (Participant.Count != 0))
      {
        writer.WritePropertyName("participant");
        writer.WriteStartArray();

        foreach (EncounterParticipant valParticipant in Participant)
        {
          valParticipant.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Appointment != null) && (Appointment.Count != 0))
      {
        writer.WritePropertyName("appointment");
        writer.WriteStartArray();

        foreach (Reference valAppointment in Appointment)
        {
          valAppointment.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ActualPeriod != null)
      {
        writer.WritePropertyName("actualPeriod");
        ActualPeriod.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PlannedStartDate))
      {
        writer.WriteString("plannedStartDate", (string)PlannedStartDate!);
      }

      if (_PlannedStartDate != null)
      {
        writer.WritePropertyName("_plannedStartDate");
        _PlannedStartDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PlannedEndDate))
      {
        writer.WriteString("plannedEndDate", (string)PlannedEndDate!);
      }

      if (_PlannedEndDate != null)
      {
        writer.WritePropertyName("_plannedEndDate");
        _PlannedEndDate.SerializeJson(writer, options);
      }

      if (Length != null)
      {
        writer.WritePropertyName("length");
        Length.SerializeJson(writer, options);
      }

      if ((Reason != null) && (Reason.Count != 0))
      {
        writer.WritePropertyName("reason");
        writer.WriteStartArray();

        foreach (CodeableReference valReason in Reason)
        {
          valReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Diagnosis != null) && (Diagnosis.Count != 0))
      {
        writer.WritePropertyName("diagnosis");
        writer.WriteStartArray();

        foreach (EncounterDiagnosis valDiagnosis in Diagnosis)
        {
          valDiagnosis.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Account != null) && (Account.Count != 0))
      {
        writer.WritePropertyName("account");
        writer.WriteStartArray();

        foreach (Reference valAccount in Account)
        {
          valAccount.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Hospitalization != null)
      {
        writer.WritePropertyName("hospitalization");
        Hospitalization.SerializeJson(writer, options);
      }

      if ((Location != null) && (Location.Count != 0))
      {
        writer.WritePropertyName("location");
        writer.WriteStartArray();

        foreach (EncounterLocation valLocation in Location)
        {
          valLocation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (ServiceProvider != null)
      {
        writer.WritePropertyName("serviceProvider");
        ServiceProvider.SerializeJson(writer, options);
      }

      if (PartOf != null)
      {
        writer.WritePropertyName("partOf");
        PartOf.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "account":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Account = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objAccount = new fhirCsR5.Models.Reference();
            objAccount.DeserializeJson(ref reader, options);
            Account.Add(objAccount);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Account.Count == 0)
          {
            Account = null;
          }

          break;

        case "actualPeriod":
          ActualPeriod = new fhirCsR5.Models.Period();
          ActualPeriod.DeserializeJson(ref reader, options);
          break;

        case "appointment":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Appointment = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objAppointment = new fhirCsR5.Models.Reference();
            objAppointment.DeserializeJson(ref reader, options);
            Appointment.Add(objAppointment);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Appointment.Count == 0)
          {
            Appointment = null;
          }

          break;

        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objBasedOn = new fhirCsR5.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "class":
          Class = new fhirCsR5.Models.Coding();
          Class.DeserializeJson(ref reader, options);
          break;

        case "classHistory":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ClassHistory = new List<EncounterClassHistory>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.EncounterClassHistory objClassHistory = new fhirCsR5.Models.EncounterClassHistory();
            objClassHistory.DeserializeJson(ref reader, options);
            ClassHistory.Add(objClassHistory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ClassHistory.Count == 0)
          {
            ClassHistory = null;
          }

          break;

        case "diagnosis":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Diagnosis = new List<EncounterDiagnosis>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.EncounterDiagnosis objDiagnosis = new fhirCsR5.Models.EncounterDiagnosis();
            objDiagnosis.DeserializeJson(ref reader, options);
            Diagnosis.Add(objDiagnosis);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Diagnosis.Count == 0)
          {
            Diagnosis = null;
          }

          break;

        case "episodeOfCare":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          EpisodeOfCare = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objEpisodeOfCare = new fhirCsR5.Models.Reference();
            objEpisodeOfCare.DeserializeJson(ref reader, options);
            EpisodeOfCare.Add(objEpisodeOfCare);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (EpisodeOfCare.Count == 0)
          {
            EpisodeOfCare = null;
          }

          break;

        case "hospitalization":
          Hospitalization = new fhirCsR5.Models.EncounterHospitalization();
          Hospitalization.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "length":
          Length = new fhirCsR5.Models.Duration();
          Length.DeserializeJson(ref reader, options);
          break;

        case "location":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Location = new List<EncounterLocation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.EncounterLocation objLocation = new fhirCsR5.Models.EncounterLocation();
            objLocation.DeserializeJson(ref reader, options);
            Location.Add(objLocation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Location.Count == 0)
          {
            Location = null;
          }

          break;

        case "participant":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Participant = new List<EncounterParticipant>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.EncounterParticipant objParticipant = new fhirCsR5.Models.EncounterParticipant();
            objParticipant.DeserializeJson(ref reader, options);
            Participant.Add(objParticipant);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Participant.Count == 0)
          {
            Participant = null;
          }

          break;

        case "partOf":
          PartOf = new fhirCsR5.Models.Reference();
          PartOf.DeserializeJson(ref reader, options);
          break;

        case "plannedEndDate":
          PlannedEndDate = reader.GetString();
          break;

        case "_plannedEndDate":
          _PlannedEndDate = new fhirCsR5.Models.Element();
          _PlannedEndDate.DeserializeJson(ref reader, options);
          break;

        case "plannedStartDate":
          PlannedStartDate = reader.GetString();
          break;

        case "_plannedStartDate":
          _PlannedStartDate = new fhirCsR5.Models.Element();
          _PlannedStartDate.DeserializeJson(ref reader, options);
          break;

        case "priority":
          Priority = new fhirCsR5.Models.CodeableConcept();
          Priority.DeserializeJson(ref reader, options);
          break;

        case "reason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reason = new List<CodeableReference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableReference objReason = new fhirCsR5.Models.CodeableReference();
            objReason.DeserializeJson(ref reader, options);
            Reason.Add(objReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reason.Count == 0)
          {
            Reason = null;
          }

          break;

        case "serviceProvider":
          ServiceProvider = new fhirCsR5.Models.Reference();
          ServiceProvider.DeserializeJson(ref reader, options);
          break;

        case "serviceType":
          ServiceType = new fhirCsR5.Models.CodeableConcept();
          ServiceType.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "statusHistory":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          StatusHistory = new List<EncounterStatusHistory>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.EncounterStatusHistory objStatusHistory = new fhirCsR5.Models.EncounterStatusHistory();
            objStatusHistory.DeserializeJson(ref reader, options);
            StatusHistory.Add(objStatusHistory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (StatusHistory.Count == 0)
          {
            StatusHistory = null;
          }

          break;

        case "subject":
          Subject = new fhirCsR5.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "subjectStatus":
          SubjectStatus = new fhirCsR5.Models.CodeableConcept();
          SubjectStatus.DeserializeJson(ref reader, options);
          break;

        case "type":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Type = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objType = new fhirCsR5.Models.CodeableConcept();
            objType.DeserializeJson(ref reader, options);
            Type.Add(objType);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Type.Count == 0)
          {
            Type = null;
          }

          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Encounter.status field
  /// </summary>
  public static class EncounterStatusCodes {
    public const string PLANNED = "planned";
    public const string IN_PROGRESS = "in-progress";
    public const string ONHOLD = "onhold";
    public const string COMPLETED = "completed";
    public const string CANCELLED = "cancelled";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string UNKNOWN = "unknown";
    public static HashSet<string> Values = new HashSet<string>() {
      "planned",
      "in-progress",
      "onhold",
      "completed",
      "cancelled",
      "entered-in-error",
      "unknown",
    };
  }
}
