// <auto-generated />
// Built from: hl7.fhir.r4.core version: 4.0.1

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using Fhir.R4.ValueSets;
using Fhir.R4.Serialization;

namespace Fhir.R4.Models
{
  /// <summary>
  /// Limited to "real" people rather than equipment.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<ProcedurePerformer>))]
  public class ProcedurePerformer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The practitioner who was involved in the procedure.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist.
    /// </summary>
    public CodeableConcept Function { get; set; }
    /// <summary>
    /// The organization the device or practitioner was acting on behalf of.
    /// </summary>
    public Reference OnBehalfOf { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(ref Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }

      ((Fhir.R4.Models.BackboneElement)this).SerializeJson(ref writer, options, false);

      writer.WritePropertyName("actor");
      Actor.SerializeJson(ref writer, options);

      if (Function != null)
      {
        writer.WritePropertyName("function");
        Function.SerializeJson(ref writer, options);
      }

      if (OnBehalfOf != null)
      {
        writer.WritePropertyName("onBehalfOf");
        OnBehalfOf.SerializeJson(ref writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new Fhir.R4.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "function":
          Function = new Fhir.R4.Models.CodeableConcept();
          Function.DeserializeJson(ref reader, options);
          break;

        case "onBehalfOf":
          OnBehalfOf = new Fhir.R4.Models.Reference();
          OnBehalfOf.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonComponentConverter<ProcedureFocalDevice>))]
  public class ProcedureFocalDevice : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The kind of change that happened to the device during the procedure.
    /// </summary>
    public CodeableConcept Action { get; set; }
    /// <summary>
    /// The device that was manipulated (changed) during the procedure.
    /// </summary>
    public Reference Manipulated { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(ref Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }

      ((Fhir.R4.Models.BackboneElement)this).SerializeJson(ref writer, options, false);

      if (Action != null)
      {
        writer.WritePropertyName("action");
        Action.SerializeJson(ref writer, options);
      }

      writer.WritePropertyName("manipulated");
      Manipulated.SerializeJson(ref writer, options);

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "action":
          Action = new Fhir.R4.Models.CodeableConcept();
          Action.DeserializeJson(ref reader, options);
          break;

        case "manipulated":
          Manipulated = new Fhir.R4.Models.Reference();
          Manipulated.DeserializeJson(ref reader, options);
          break;

        default:
          ((Fhir.R4.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy.
  /// </summary>
  [JsonConverter(typeof(Fhir.R4.Serialization.JsonResourceConverter))]
  public class Procedure : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public string ResourceType => "Procedure";
    /// <summary>
    /// Individual who is making the procedure statement.
    /// </summary>
    public Reference Asserter { get; set; }
    /// <summary>
    /// A reference to a resource that contains details of the request for this procedure.
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// If the use case requires attributes from the BodySite resource (e.g. to identify and track separately) then use the standard extension [procedure-targetbodystructure](extension-procedure-targetbodystructure.html).
    /// </summary>
    public List<CodeableConcept> BodySite { get; set; }
    /// <summary>
    /// A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    /// </summary>
    public CodeableConcept Category { get; set; }
    /// <summary>
    /// The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    /// </summary>
    public CodeableConcept Code { get; set; }
    /// <summary>
    /// If complications are only expressed by the narrative text, they can be captured using the CodeableConcept.text.
    /// </summary>
    public List<CodeableConcept> Complication { get; set; }
    /// <summary>
    /// Any complications that occurred during the procedure, or in the immediate post-performance period.
    /// </summary>
    public List<Reference> ComplicationDetail { get; set; }
    /// <summary>
    /// This will typically be the encounter the event occurred within, but some activities may be initiated prior to or after the official completion of an encounter but still be tied to the context of the encounter.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    /// </summary>
    public List<ProcedureFocalDevice> FocalDevice { get; set; }
    /// <summary>
    /// If the procedure required specific follow up - e.g. removal of sutures. The follow up may be represented as a simple note or could potentially be more complex, in which case the CarePlan resource can be used.
    /// </summary>
    public List<CodeableConcept> FollowUp { get; set; }
    /// <summary>
    /// This is a business identifier, not a resource identifier (see [discussion](resource.html#identifiers)).  It is best practice for the identifier to only appear on a single resource instance, however business practices may occasionally dictate that multiple resource instances with the same identifier can exist - possibly even with different resource types.  For example, multiple Patient and Person resource instances might share the same social insurance number.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// The URL pointing to a FHIR-defined protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
    /// </summary>
    public List<string> InstantiatesCanonical { get; set; }
    /// <summary>
    /// Extension container element for InstantiatesCanonical
    /// </summary>
    public List<Element> _InstantiatesCanonical { get; set; }
    /// <summary>
    /// This might be an HTML page, PDF, etc. or could just be a non-resolvable URI identifier.
    /// </summary>
    public List<string> InstantiatesUri { get; set; }
    /// <summary>
    /// Extension container element for InstantiatesUri
    /// </summary>
    public List<Element> _InstantiatesUri { get; set; }
    /// <summary>
    /// The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
    /// </summary>
    public Reference Location { get; set; }
    /// <summary>
    /// Any other notes and comments about the procedure.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// If outcome contains narrative text only, it can be captured using the CodeableConcept.text.
    /// </summary>
    public CodeableConcept Outcome { get; set; }
    /// <summary>
    /// The MedicationAdministration resource has a partOf reference to Procedure, but this is not a circular reference.   For example, the anesthesia MedicationAdministration is part of the surgical Procedure (MedicationAdministration.partOf = Procedure).  For example, the procedure to insert the IV port for an IV medication administration is part of the medication administration (Procedure.partOf = MedicationAdministration).
    /// </summary>
    public List<Reference> PartOf { get; set; }
    /// <summary>
    /// Age is generally used when the patient reports an age at which the procedure was performed. Range is generally used when the patient reports an age range when the procedure was performed, such as sometime between 20-25 years old.  dateTime supports a range of precision due to some procedures being reported as past procedures that might not have millisecond precision while other procedures performed and documented during the encounter might have more precise UTC timestamps with timezone.
    /// </summary>
    public string PerformedDateTime { get; set; }
    /// <summary>
    /// Extension container element for PerformedDateTime
    /// </summary>
    public Element _PerformedDateTime { get; set; }
    /// <summary>
    /// Age is generally used when the patient reports an age at which the procedure was performed. Range is generally used when the patient reports an age range when the procedure was performed, such as sometime between 20-25 years old.  dateTime supports a range of precision due to some procedures being reported as past procedures that might not have millisecond precision while other procedures performed and documented during the encounter might have more precise UTC timestamps with timezone.
    /// </summary>
    public Period PerformedPeriod { get; set; }
    /// <summary>
    /// Age is generally used when the patient reports an age at which the procedure was performed. Range is generally used when the patient reports an age range when the procedure was performed, such as sometime between 20-25 years old.  dateTime supports a range of precision due to some procedures being reported as past procedures that might not have millisecond precision while other procedures performed and documented during the encounter might have more precise UTC timestamps with timezone.
    /// </summary>
    public string PerformedString { get; set; }
    /// <summary>
    /// Extension container element for PerformedString
    /// </summary>
    public Element _PerformedString { get; set; }
    /// <summary>
    /// Age is generally used when the patient reports an age at which the procedure was performed. Range is generally used when the patient reports an age range when the procedure was performed, such as sometime between 20-25 years old.  dateTime supports a range of precision due to some procedures being reported as past procedures that might not have millisecond precision while other procedures performed and documented during the encounter might have more precise UTC timestamps with timezone.
    /// </summary>
    public Age PerformedAge { get; set; }
    /// <summary>
    /// Age is generally used when the patient reports an age at which the procedure was performed. Range is generally used when the patient reports an age range when the procedure was performed, such as sometime between 20-25 years old.  dateTime supports a range of precision due to some procedures being reported as past procedures that might not have millisecond precision while other procedures performed and documented during the encounter might have more precise UTC timestamps with timezone.
    /// </summary>
    public Range PerformedRange { get; set; }
    /// <summary>
    /// Limited to "real" people rather than equipment.
    /// </summary>
    public List<ProcedurePerformer> Performer { get; set; }
    /// <summary>
    /// Use Procedure.reasonCode when a code sufficiently describes the reason.  Use Procedure.reasonReference when referencing a resource, which allows more information to be conveyed, such as onset date. Procedure.reasonCode and Procedure.reasonReference are not meant to be duplicative.  For a single reason, either Procedure.reasonCode or Procedure.reasonReference can be used.  Procedure.reasonCode may be a summary code, or Procedure.reasonReference may be used to reference a very precise definition of the reason using Condition | Observation | Procedure | DiagnosticReport | DocumentReference.  Both Procedure.reasonCode and Procedure.reasonReference can be used if they are describing different reasons for the procedure.
    /// </summary>
    public List<CodeableConcept> ReasonCode { get; set; }
    /// <summary>
    /// It is possible for a procedure to be a reason (such as C-Section) for another procedure (such as an epidural). Other examples include endoscopy for dilatation and biopsy (a combination of diagnostic and therapeutic use). 
    /// Use Procedure.reasonCode when a code sufficiently describes the reason.  Use Procedure.reasonReference when referencing a resource, which allows more information to be conveyed, such as onset date. Procedure.reasonCode and Procedure.reasonReference are not meant to be duplicative.  For a single reason, either Procedure.reasonCode or Procedure.reasonReference can be used.  Procedure.reasonCode may be a summary code, or Procedure.reasonReference may be used to reference a very precise definition of the reason using Condition | Observation | Procedure | DiagnosticReport | DocumentReference.  Both Procedure.reasonCode and Procedure.reasonReference can be used if they are describing different reasons for the procedure.
    /// </summary>
    public List<Reference> ReasonReference { get; set; }
    /// <summary>
    /// Individual who recorded the record and takes responsibility for its content.
    /// </summary>
    public Reference Recorder { get; set; }
    /// <summary>
    /// There could potentially be multiple reports - e.g. if this was a procedure which took multiple biopsies resulting in a number of anatomical pathology reports.
    /// </summary>
    public List<Reference> Report { get; set; }
    /// <summary>
    /// The "unknown" code is not to be used to convey other statuses.  The "unknown" code should be used when one of the statuses applies, but the authoring system doesn't know the current state of the procedure.
    /// This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// This is generally only used for "exception" statuses such as "not-done", "suspended" or "aborted". The reason for performing the event at all is captured in reasonCode, not here.
    /// </summary>
    public CodeableConcept StatusReason { get; set; }
    /// <summary>
    /// The person, animal or group on which the procedure was performed.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// For devices actually implanted or removed, use Procedure.device.
    /// </summary>
    public List<CodeableConcept> UsedCode { get; set; }
    /// <summary>
    /// For devices actually implanted or removed, use Procedure.device.
    /// </summary>
    public List<Reference> UsedReference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(ref Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }

      writer.WriteString("resourceType", ResourceType);


      ((Fhir.R4.Models.DomainResource)this).SerializeJson(ref writer, options, false);

      if (Asserter != null)
      {
        writer.WritePropertyName("asserter");
        Asserter.SerializeJson(ref writer, options);
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BodySite != null) && (BodySite.Count != 0))
      {
        writer.WritePropertyName("bodySite");
        writer.WriteStartArray();

        foreach (CodeableConcept valBodySite in BodySite)
        {
          valBodySite.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Category != null)
      {
        writer.WritePropertyName("category");
        Category.SerializeJson(ref writer, options);
      }

      if (Code != null)
      {
        writer.WritePropertyName("code");
        Code.SerializeJson(ref writer, options);
      }

      if ((Complication != null) && (Complication.Count != 0))
      {
        writer.WritePropertyName("complication");
        writer.WriteStartArray();

        foreach (CodeableConcept valComplication in Complication)
        {
          valComplication.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ComplicationDetail != null) && (ComplicationDetail.Count != 0))
      {
        writer.WritePropertyName("complicationDetail");
        writer.WriteStartArray();

        foreach (Reference valComplicationDetail in ComplicationDetail)
        {
          valComplicationDetail.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(ref writer, options);
      }

      if ((FocalDevice != null) && (FocalDevice.Count != 0))
      {
        writer.WritePropertyName("focalDevice");
        writer.WriteStartArray();

        foreach (ProcedureFocalDevice valFocalDevice in FocalDevice)
        {
          valFocalDevice.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((FollowUp != null) && (FollowUp.Count != 0))
      {
        writer.WritePropertyName("followUp");
        writer.WriteStartArray();

        foreach (CodeableConcept valFollowUp in FollowUp)
        {
          valFollowUp.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((InstantiatesCanonical != null) && (InstantiatesCanonical.Count != 0))
      {
        writer.WritePropertyName("instantiatesCanonical");
        writer.WriteStartArray();

        foreach (string valInstantiatesCanonical in InstantiatesCanonical)
        {
          writer.WriteStringValue(valInstantiatesCanonical);
        }

        writer.WriteEndArray();
      }

      if ((_InstantiatesCanonical != null) && (_InstantiatesCanonical.Count != 0))
      {
        writer.WritePropertyName("_instantiatesCanonical");
        writer.WriteStartArray();

        foreach (Element val_InstantiatesCanonical in _InstantiatesCanonical)
        {
          val_InstantiatesCanonical.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((InstantiatesUri != null) && (InstantiatesUri.Count != 0))
      {
        writer.WritePropertyName("instantiatesUri");
        writer.WriteStartArray();

        foreach (string valInstantiatesUri in InstantiatesUri)
        {
          writer.WriteStringValue(valInstantiatesUri);
        }

        writer.WriteEndArray();
      }

      if ((_InstantiatesUri != null) && (_InstantiatesUri.Count != 0))
      {
        writer.WritePropertyName("_instantiatesUri");
        writer.WriteStartArray();

        foreach (Element val_InstantiatesUri in _InstantiatesUri)
        {
          val_InstantiatesUri.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(ref writer, options);
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Outcome != null)
      {
        writer.WritePropertyName("outcome");
        Outcome.SerializeJson(ref writer, options);
      }

      if ((PartOf != null) && (PartOf.Count != 0))
      {
        writer.WritePropertyName("partOf");
        writer.WriteStartArray();

        foreach (Reference valPartOf in PartOf)
        {
          valPartOf.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      writer.WriteString("performedDateTime", PerformedDateTime);

      if (_PerformedDateTime != null)
      {
        writer.WritePropertyName("_performedDateTime");
        _PerformedDateTime.SerializeJson(ref writer, options);
      }

      if (PerformedPeriod != null)
      {
        writer.WritePropertyName("performedPeriod");
        PerformedPeriod.SerializeJson(ref writer, options);
      }

      writer.WriteString("performedString", PerformedString);

      if (_PerformedString != null)
      {
        writer.WritePropertyName("_performedString");
        _PerformedString.SerializeJson(ref writer, options);
      }

      if (PerformedAge != null)
      {
        writer.WritePropertyName("performedAge");
        PerformedAge.SerializeJson(ref writer, options);
      }

      if (PerformedRange != null)
      {
        writer.WritePropertyName("performedRange");
        PerformedRange.SerializeJson(ref writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (ProcedurePerformer valPerformer in Performer)
        {
          valPerformer.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ReasonCode != null) && (ReasonCode.Count != 0))
      {
        writer.WritePropertyName("reasonCode");
        writer.WriteStartArray();

        foreach (CodeableConcept valReasonCode in ReasonCode)
        {
          valReasonCode.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ReasonReference != null) && (ReasonReference.Count != 0))
      {
        writer.WritePropertyName("reasonReference");
        writer.WriteStartArray();

        foreach (Reference valReasonReference in ReasonReference)
        {
          valReasonReference.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Recorder != null)
      {
        writer.WritePropertyName("recorder");
        Recorder.SerializeJson(ref writer, options);
      }

      if ((Report != null) && (Report.Count != 0))
      {
        writer.WritePropertyName("report");
        writer.WriteStartArray();

        foreach (Reference valReport in Report)
        {
          valReport.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      writer.WriteString("status", Status);

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(ref writer, options);
      }

      if (StatusReason != null)
      {
        writer.WritePropertyName("statusReason");
        StatusReason.SerializeJson(ref writer, options);
      }

      writer.WritePropertyName("subject");
      Subject.SerializeJson(ref writer, options);

      if ((UsedCode != null) && (UsedCode.Count != 0))
      {
        writer.WritePropertyName("usedCode");
        writer.WriteStartArray();

        foreach (CodeableConcept valUsedCode in UsedCode)
        {
          valUsedCode.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((UsedReference != null) && (UsedReference.Count != 0))
      {
        writer.WritePropertyName("usedReference");
        writer.WriteStartArray();

        foreach (Reference valUsedReference in UsedReference)
        {
          valUsedReference.SerializeJson(ref writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "asserter":
          Asserter = new Fhir.R4.Models.Reference();
          Asserter.DeserializeJson(ref reader, options);
          break;

        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objBasedOn = new Fhir.R4.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "bodySite":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BodySite = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objBodySite = new Fhir.R4.Models.CodeableConcept();
            objBodySite.DeserializeJson(ref reader, options);
            BodySite.Add(objBodySite);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BodySite.Count == 0)
          {
            BodySite = null;
          }

          break;

        case "category":
          Category = new Fhir.R4.Models.CodeableConcept();
          Category.DeserializeJson(ref reader, options);
          break;

        case "code":
          Code = new Fhir.R4.Models.CodeableConcept();
          Code.DeserializeJson(ref reader, options);
          break;

        case "complication":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Complication = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objComplication = new Fhir.R4.Models.CodeableConcept();
            objComplication.DeserializeJson(ref reader, options);
            Complication.Add(objComplication);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Complication.Count == 0)
          {
            Complication = null;
          }

          break;

        case "complicationDetail":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ComplicationDetail = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objComplicationDetail = new Fhir.R4.Models.Reference();
            objComplicationDetail.DeserializeJson(ref reader, options);
            ComplicationDetail.Add(objComplicationDetail);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ComplicationDetail.Count == 0)
          {
            ComplicationDetail = null;
          }

          break;

        case "encounter":
          Encounter = new Fhir.R4.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "focalDevice":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          FocalDevice = new List<ProcedureFocalDevice>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.ProcedureFocalDevice objFocalDevice = new Fhir.R4.Models.ProcedureFocalDevice();
            objFocalDevice.DeserializeJson(ref reader, options);
            FocalDevice.Add(objFocalDevice);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (FocalDevice.Count == 0)
          {
            FocalDevice = null;
          }

          break;

        case "followUp":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          FollowUp = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objFollowUp = new Fhir.R4.Models.CodeableConcept();
            objFollowUp.DeserializeJson(ref reader, options);
            FollowUp.Add(objFollowUp);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (FollowUp.Count == 0)
          {
            FollowUp = null;
          }

          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Identifier objIdentifier = new Fhir.R4.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "instantiatesCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          InstantiatesCanonical = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            InstantiatesCanonical.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (InstantiatesCanonical.Count == 0)
          {
            InstantiatesCanonical = null;
          }

          break;

        case "_instantiatesCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _InstantiatesCanonical = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Element obj_InstantiatesCanonical = new Fhir.R4.Models.Element();
            obj_InstantiatesCanonical.DeserializeJson(ref reader, options);
            _InstantiatesCanonical.Add(obj_InstantiatesCanonical);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_InstantiatesCanonical.Count == 0)
          {
            _InstantiatesCanonical = null;
          }

          break;

        case "instantiatesUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          InstantiatesUri = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            InstantiatesUri.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (InstantiatesUri.Count == 0)
          {
            InstantiatesUri = null;
          }

          break;

        case "_instantiatesUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _InstantiatesUri = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Element obj_InstantiatesUri = new Fhir.R4.Models.Element();
            obj_InstantiatesUri.DeserializeJson(ref reader, options);
            _InstantiatesUri.Add(obj_InstantiatesUri);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_InstantiatesUri.Count == 0)
          {
            _InstantiatesUri = null;
          }

          break;

        case "location":
          Location = new Fhir.R4.Models.Reference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Annotation objNote = new Fhir.R4.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "outcome":
          Outcome = new Fhir.R4.Models.CodeableConcept();
          Outcome.DeserializeJson(ref reader, options);
          break;

        case "partOf":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          PartOf = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objPartOf = new Fhir.R4.Models.Reference();
            objPartOf.DeserializeJson(ref reader, options);
            PartOf.Add(objPartOf);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (PartOf.Count == 0)
          {
            PartOf = null;
          }

          break;

        case "performedDateTime":
          PerformedDateTime = reader.GetString();
          break;

        case "_performedDateTime":
          _PerformedDateTime = new Fhir.R4.Models.Element();
          _PerformedDateTime.DeserializeJson(ref reader, options);
          break;

        case "performedPeriod":
          PerformedPeriod = new Fhir.R4.Models.Period();
          PerformedPeriod.DeserializeJson(ref reader, options);
          break;

        case "performedString":
          PerformedString = reader.GetString();
          break;

        case "_performedString":
          _PerformedString = new Fhir.R4.Models.Element();
          _PerformedString.DeserializeJson(ref reader, options);
          break;

        case "performedAge":
          PerformedAge = new Fhir.R4.Models.Age();
          PerformedAge.DeserializeJson(ref reader, options);
          break;

        case "performedRange":
          PerformedRange = new Fhir.R4.Models.Range();
          PerformedRange.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<ProcedurePerformer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.ProcedurePerformer objPerformer = new Fhir.R4.Models.ProcedurePerformer();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "reasonCode":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ReasonCode = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objReasonCode = new Fhir.R4.Models.CodeableConcept();
            objReasonCode.DeserializeJson(ref reader, options);
            ReasonCode.Add(objReasonCode);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ReasonCode.Count == 0)
          {
            ReasonCode = null;
          }

          break;

        case "reasonReference":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ReasonReference = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objReasonReference = new Fhir.R4.Models.Reference();
            objReasonReference.DeserializeJson(ref reader, options);
            ReasonReference.Add(objReasonReference);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ReasonReference.Count == 0)
          {
            ReasonReference = null;
          }

          break;

        case "recorder":
          Recorder = new Fhir.R4.Models.Reference();
          Recorder.DeserializeJson(ref reader, options);
          break;

        case "report":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Report = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objReport = new Fhir.R4.Models.Reference();
            objReport.DeserializeJson(ref reader, options);
            Report.Add(objReport);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Report.Count == 0)
          {
            Report = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new Fhir.R4.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "statusReason":
          StatusReason = new Fhir.R4.Models.CodeableConcept();
          StatusReason.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new Fhir.R4.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "usedCode":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UsedCode = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.CodeableConcept objUsedCode = new Fhir.R4.Models.CodeableConcept();
            objUsedCode.DeserializeJson(ref reader, options);
            UsedCode.Add(objUsedCode);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UsedCode.Count == 0)
          {
            UsedCode = null;
          }

          break;

        case "usedReference":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UsedReference = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            Fhir.R4.Models.Reference objUsedReference = new Fhir.R4.Models.Reference();
            objUsedReference.DeserializeJson(ref reader, options);
            UsedReference.Add(objUsedReference);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UsedReference.Count == 0)
          {
            UsedReference = null;
          }

          break;

        default:
          ((Fhir.R4.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
}
