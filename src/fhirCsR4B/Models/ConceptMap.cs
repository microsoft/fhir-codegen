// <auto-generated />
// Built from: hl7.fhir.r4b.core version: 4.3.0-snapshot1
  // Option: "NAMESPACE" = "fhirCsR4B"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR4B.Serialization;

namespace fhirCsR4B.Models
{
  /// <summary>
  /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMapGroupElementTargetDependsOn>))]
  public class ConceptMapGroupElementTargetDependsOn : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somewhere that is labeled to correspond with a code system property.
    /// </summary>
    public string Property { get; set; }
    /// <summary>
    /// Extension container element for Property
    /// </summary>
    public Element _Property { get; set; }
    /// <summary>
    /// An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    /// </summary>
    public string System { get; set; }
    /// <summary>
    /// Extension container element for System
    /// </summary>
    public Element _System { get; set; }
    /// <summary>
    /// Identity (code or path) or the element/item/ValueSet/text that the map depends on / refers to.
    /// </summary>
    public string Value { get; set; }
    /// <summary>
    /// Extension container element for Value
    /// </summary>
    public Element _Value { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4B.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Property))
      {
        writer.WriteString("property", (string)Property!);
      }

      if (_Property != null)
      {
        writer.WritePropertyName("_property");
        _Property.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(System))
      {
        writer.WriteString("system", (string)System!);
      }

      if (_System != null)
      {
        writer.WritePropertyName("_system");
        _System.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Value))
      {
        writer.WriteString("value", (string)Value!);
      }

      if (_Value != null)
      {
        writer.WritePropertyName("_value");
        _Value.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR4B.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "property":
          Property = reader.GetString();
          break;

        case "_property":
          _Property = new fhirCsR4B.Models.Element();
          _Property.DeserializeJson(ref reader, options);
          break;

        case "system":
          System = reader.GetString();
          break;

        case "_system":
          _System = new fhirCsR4B.Models.Element();
          _System.DeserializeJson(ref reader, options);
          break;

        case "value":
          Value = reader.GetString();
          break;

        case "_value":
          _Value = new fhirCsR4B.Models.Element();
          _Value.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4B.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMapGroupElementTarget>))]
  public class ConceptMapGroupElementTarget : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identity (code or path) or the element/item that the map refers to.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    /// </summary>
    public string Comment { get; set; }
    /// <summary>
    /// Extension container element for Comment
    /// </summary>
    public Element _Comment { get; set; }
    /// <summary>
    /// A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    /// </summary>
    public List<ConceptMapGroupElementTargetDependsOn> DependsOn { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// This element is labeled as a modifier because it may indicate that a target does not apply.
    /// </summary>
    public string Equivalence { get; set; }
    /// <summary>
    /// Extension container element for Equivalence
    /// </summary>
    public Element _Equivalence { get; set; }
    /// <summary>
    /// A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    /// </summary>
    public List<ConceptMapGroupElementTargetDependsOn> Product { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4B.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Equivalence))
      {
        writer.WriteString("equivalence", (string)Equivalence!);
      }

      if (_Equivalence != null)
      {
        writer.WritePropertyName("_equivalence");
        _Equivalence.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Comment))
      {
        writer.WriteString("comment", (string)Comment!);
      }

      if (_Comment != null)
      {
        writer.WritePropertyName("_comment");
        _Comment.SerializeJson(writer, options);
      }

      if ((DependsOn != null) && (DependsOn.Count != 0))
      {
        writer.WritePropertyName("dependsOn");
        writer.WriteStartArray();

        foreach (ConceptMapGroupElementTargetDependsOn valDependsOn in DependsOn)
        {
          valDependsOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Product != null) && (Product.Count != 0))
      {
        writer.WritePropertyName("product");
        writer.WriteStartArray();

        foreach (ConceptMapGroupElementTargetDependsOn valProduct in Product)
        {
          valProduct.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR4B.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "comment":
          Comment = reader.GetString();
          break;

        case "_comment":
          _Comment = new fhirCsR4B.Models.Element();
          _Comment.DeserializeJson(ref reader, options);
          break;

        case "dependsOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DependsOn = new List<ConceptMapGroupElementTargetDependsOn>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ConceptMapGroupElementTargetDependsOn objDependsOn = new fhirCsR4B.Models.ConceptMapGroupElementTargetDependsOn();
            objDependsOn.DeserializeJson(ref reader, options);
            DependsOn.Add(objDependsOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DependsOn.Count == 0)
          {
            DependsOn = null;
          }

          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR4B.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "equivalence":
          Equivalence = reader.GetString();
          break;

        case "_equivalence":
          _Equivalence = new fhirCsR4B.Models.Element();
          _Equivalence.DeserializeJson(ref reader, options);
          break;

        case "product":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Product = new List<ConceptMapGroupElementTargetDependsOn>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ConceptMapGroupElementTargetDependsOn objProduct = new fhirCsR4B.Models.ConceptMapGroupElementTargetDependsOn();
            objProduct.DeserializeJson(ref reader, options);
            Product.Add(objProduct);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Product.Count == 0)
          {
            Product = null;
          }

          break;

        default:
          ((fhirCsR4B.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap.group.element.target.equivalence field
  /// </summary>
  public static class ConceptMapGroupElementTargetEquivalenceCodes {
    public const string RELATEDTO = "relatedto";
    public const string EQUIVALENT = "equivalent";
    public const string EQUAL = "equal";
    public const string WIDER = "wider";
    public const string SUBSUMES = "subsumes";
    public const string NARROWER = "narrower";
    public const string SPECIALIZES = "specializes";
    public const string INEXACT = "inexact";
    public const string UNMATCHED = "unmatched";
    public const string DISJOINT = "disjoint";
  }
  /// <summary>
  /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMapGroupElement>))]
  public class ConceptMapGroupElement : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identity (code or path) or the element/item being mapped.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// Ideally there would only be one map, with equal or equivalent mapping. But multiple maps are allowed for several narrower options, or to assert that other concepts are unmatched.
    /// </summary>
    public List<ConceptMapGroupElementTarget> Target { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4B.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if ((Target != null) && (Target.Count != 0))
      {
        writer.WritePropertyName("target");
        writer.WriteStartArray();

        foreach (ConceptMapGroupElementTarget valTarget in Target)
        {
          valTarget.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR4B.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR4B.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "target":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Target = new List<ConceptMapGroupElementTarget>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ConceptMapGroupElementTarget objTarget = new fhirCsR4B.Models.ConceptMapGroupElementTarget();
            objTarget.DeserializeJson(ref reader, options);
            Target.Add(objTarget);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Target.Count == 0)
          {
            Target = null;
          }

          break;

        default:
          ((fhirCsR4B.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// This only applies if the source code has a system value that matches the system defined for the group.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMapGroupUnmapped>))]
  public class ConceptMapGroupUnmapped : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    /// </summary>
    public string Code { get; set; }
    /// <summary>
    /// Extension container element for Code
    /// </summary>
    public Element _Code { get; set; }
    /// <summary>
    /// The display is ignored when processing the map.
    /// </summary>
    public string Display { get; set; }
    /// <summary>
    /// Extension container element for Display
    /// </summary>
    public Element _Display { get; set; }
    /// <summary>
    /// Defines which action to take if there is no match for the source concept in the target system designated for the group. One of 3 actions are possible: use the unmapped code (this is useful when doing a mapping between versions, and only a few codes have changed), use a fixed code (a default code), or alternatively, a reference to a different concept map can be provided (by canonical URL).
    /// </summary>
    public string Mode { get; set; }
    /// <summary>
    /// Extension container element for Mode
    /// </summary>
    public Element _Mode { get; set; }
    /// <summary>
    /// The canonical reference to an additional ConceptMap resource instance to use for mapping if this ConceptMap resource contains no matching mapping for the source concept.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4B.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Mode))
      {
        writer.WriteString("mode", (string)Mode!);
      }

      if (_Mode != null)
      {
        writer.WritePropertyName("_mode");
        _Mode.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Code))
      {
        writer.WriteString("code", (string)Code!);
      }

      if (_Code != null)
      {
        writer.WritePropertyName("_code");
        _Code.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Display))
      {
        writer.WriteString("display", (string)Display!);
      }

      if (_Display != null)
      {
        writer.WritePropertyName("_display");
        _Display.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "code":
          Code = reader.GetString();
          break;

        case "_code":
          _Code = new fhirCsR4B.Models.Element();
          _Code.DeserializeJson(ref reader, options);
          break;

        case "display":
          Display = reader.GetString();
          break;

        case "_display":
          _Display = new fhirCsR4B.Models.Element();
          _Display.DeserializeJson(ref reader, options);
          break;

        case "mode":
          Mode = reader.GetString();
          break;

        case "_mode":
          _Mode = new fhirCsR4B.Models.Element();
          _Mode.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR4B.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4B.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap.group.unmapped.mode field
  /// </summary>
  public static class ConceptMapGroupUnmappedModeCodes {
    public const string PROVIDED = "provided";
    public const string VAL_FIXED = "fixed";
    public const string OTHER_MAP = "other-map";
  }
  /// <summary>
  /// A group of mappings that all have the same source and target system.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMapGroup>))]
  public class ConceptMapGroup : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Generally, the ideal is that there would only be one mapping for each concept in the source value set, but a given concept may be mapped multiple times with different comments or dependencies.
    /// </summary>
    public List<ConceptMapGroupElement> Element { get; set; }
    /// <summary>
    /// This is not needed if the source value set is specified and it contains concepts from only a single system.
    /// </summary>
    public string Source { get; set; }
    /// <summary>
    /// Extension container element for Source
    /// </summary>
    public Element _Source { get; set; }
    /// <summary>
    /// The specification of a particular code system version may be required for code systems which lack concept permanence.
    /// </summary>
    public string SourceVersion { get; set; }
    /// <summary>
    /// Extension container element for SourceVersion
    /// </summary>
    public Element _SourceVersion { get; set; }
    /// <summary>
    /// This is not needed if the target value set is specified and it contains concepts from only a single system. The group target may also be omitted if all of the target element equivalence values are 'unmatched'.
    /// </summary>
    public string Target { get; set; }
    /// <summary>
    /// Extension container element for Target
    /// </summary>
    public Element _Target { get; set; }
    /// <summary>
    /// The specification of a particular code system version may be required for code systems which lack concept permanence.
    /// </summary>
    public string TargetVersion { get; set; }
    /// <summary>
    /// Extension container element for TargetVersion
    /// </summary>
    public Element _TargetVersion { get; set; }
    /// <summary>
    /// This only applies if the source code has a system value that matches the system defined for the group.
    /// </summary>
    public ConceptMapGroupUnmapped Unmapped { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR4B.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Source))
      {
        writer.WriteString("source", (string)Source!);
      }

      if (_Source != null)
      {
        writer.WritePropertyName("_source");
        _Source.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SourceVersion))
      {
        writer.WriteString("sourceVersion", (string)SourceVersion!);
      }

      if (_SourceVersion != null)
      {
        writer.WritePropertyName("_sourceVersion");
        _SourceVersion.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Target))
      {
        writer.WriteString("target", (string)Target!);
      }

      if (_Target != null)
      {
        writer.WritePropertyName("_target");
        _Target.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TargetVersion))
      {
        writer.WriteString("targetVersion", (string)TargetVersion!);
      }

      if (_TargetVersion != null)
      {
        writer.WritePropertyName("_targetVersion");
        _TargetVersion.SerializeJson(writer, options);
      }

      if ((Element != null) && (Element.Count != 0))
      {
        writer.WritePropertyName("element");
        writer.WriteStartArray();

        foreach (ConceptMapGroupElement valElement in Element)
        {
          valElement.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Unmapped != null)
      {
        writer.WritePropertyName("unmapped");
        Unmapped.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "element":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Element = new List<ConceptMapGroupElement>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ConceptMapGroupElement objElement = new fhirCsR4B.Models.ConceptMapGroupElement();
            objElement.DeserializeJson(ref reader, options);
            Element.Add(objElement);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Element.Count == 0)
          {
            Element = null;
          }

          break;

        case "source":
          Source = reader.GetString();
          break;

        case "_source":
          _Source = new fhirCsR4B.Models.Element();
          _Source.DeserializeJson(ref reader, options);
          break;

        case "sourceVersion":
          SourceVersion = reader.GetString();
          break;

        case "_sourceVersion":
          _SourceVersion = new fhirCsR4B.Models.Element();
          _SourceVersion.DeserializeJson(ref reader, options);
          break;

        case "target":
          Target = reader.GetString();
          break;

        case "_target":
          _Target = new fhirCsR4B.Models.Element();
          _Target.DeserializeJson(ref reader, options);
          break;

        case "targetVersion":
          TargetVersion = reader.GetString();
          break;

        case "_targetVersion":
          _TargetVersion = new fhirCsR4B.Models.Element();
          _TargetVersion.DeserializeJson(ref reader, options);
          break;

        case "unmapped":
          Unmapped = new fhirCsR4B.Models.ConceptMapGroupUnmapped();
          Unmapped.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4B.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models.
  /// </summary>
  [JsonConverter(typeof(fhirCsR4B.Serialization.JsonStreamComponentConverter<ConceptMap>))]
  public class ConceptMap : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "ConceptMap";
    /// <summary>
    /// May be a web site, an email address, a telephone number, etc.
    /// </summary>
    public List<ContactDetail> Contact { get; set; }
    /// <summary>
    /// Frequently the copyright differs between the concept map and codes that are included. The copyright statement should clearly differentiate between these when required.
    /// </summary>
    public string Copyright { get; set; }
    /// <summary>
    /// Extension container element for Copyright
    /// </summary>
    public Element _Copyright { get; set; }
    /// <summary>
    /// Note that this is not the same as the resource last-modified-date, since the resource may be a secondary representation of the concept map. Additional specific dates may be added as extensions or be found by consulting Provenances associated with past versions of the resource.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// The description is not intended to describe the semantics of the concept map. The description should capture its intended use, which is needed for ensuring integrity for its use in models across future changes.
    /// </summary>
    public string Description { get; set; }
    /// <summary>
    /// Extension container element for Description
    /// </summary>
    public Element _Description { get; set; }
    /// <summary>
    /// Allows filtering of concept maps that are appropriate for use versus not.
    /// </summary>
    public bool? Experimental { get; set; }
    /// <summary>
    /// A group of mappings that all have the same source and target system.
    /// </summary>
    public List<ConceptMapGroup> Group { get; set; }
    /// <summary>
    /// Typically, this is used for identifiers that can go in an HL7 V3 II (instance identifier) data type, and can then identify this concept map outside of FHIR, where it is not possible to use the logical URI.
    /// </summary>
    public Identifier Identifier { get; set; }
    /// <summary>
    /// It may be possible for the concept map to be used in jurisdictions other than those for which it was originally designed or intended.
    /// </summary>
    public List<CodeableConcept> Jurisdiction { get; set; }
    /// <summary>
    /// The name is not expected to be globally unique. The name should be a simple alphanumeric type name to ensure that it is machine-processing friendly.
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// Extension container element for Name
    /// </summary>
    public Element _Name { get; set; }
    /// <summary>
    /// Usually an organization but may be an individual. The publisher (or steward) of the concept map is the organization or individual primarily responsible for the maintenance and upkeep of the concept map. This is not necessarily the same individual or organization that developed and initially authored the content. The publisher is the primary point of contact for questions or issues with the concept map. This item SHOULD be populated unless the information is available from context.
    /// </summary>
    public string Publisher { get; set; }
    /// <summary>
    /// Extension container element for Publisher
    /// </summary>
    public Element _Publisher { get; set; }
    /// <summary>
    /// This element does not describe the usage of the concept map. Instead, it provides traceability of ''why'' the resource is either needed or ''why'' it is defined as it is.  This may be used to point to source materials or specifications that drove the structure of this concept map.
    /// </summary>
    public string Purpose { get; set; }
    /// <summary>
    /// Extension container element for Purpose
    /// </summary>
    public Element _Purpose { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, there is no specified context for the map (not recommended).  The source value set may select codes from either an explicit (standard or local) or implicit code system.
    /// </summary>
    public string SourceUri { get; set; }
    /// <summary>
    /// Extension container element for SourceUri
    /// </summary>
    public Element _SourceUri { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, there is no specified context for the map (not recommended).  The source value set may select codes from either an explicit (standard or local) or implicit code system.
    /// </summary>
    public string SourceCanonical { get; set; }
    /// <summary>
    /// Extension container element for SourceCanonical
    /// </summary>
    public Element _SourceCanonical { get; set; }
    /// <summary>
    /// Allows filtering of concept maps that are appropriate for use versus not.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
    /// </summary>
    public string TargetUri { get; set; }
    /// <summary>
    /// Extension container element for TargetUri
    /// </summary>
    public Element _TargetUri { get; set; }
    /// <summary>
    /// Should be a version specific reference. URIs SHOULD be absolute. If there is no source or target value set, the is no specified context for the map.
    /// </summary>
    public string TargetCanonical { get; set; }
    /// <summary>
    /// Extension container element for TargetCanonical
    /// </summary>
    public Element _TargetCanonical { get; set; }
    /// <summary>
    /// This name does not need to be machine-processing friendly and may contain punctuation, white-space, etc.
    /// </summary>
    public string Title { get; set; }
    /// <summary>
    /// Extension container element for Title
    /// </summary>
    public Element _Title { get; set; }
    /// <summary>
    /// Can be a urn:uuid: or a urn:oid: but real http: addresses are preferred.  Multiple instances may share the same URL if they have a distinct version.
    /// The determination of when to create a new version of a resource (same url, new version) vs. defining a new artifact is up to the author.  Considerations for making this decision are found in [Technical and Business Versions](resource.html#versions). 
    /// In some cases, the resource can no longer be found at the stated url, but the url itself cannot change. Implementations can use the [meta.source](resource.html#meta) element to indicate where the current master source of the resource can be found.
    /// </summary>
    public string Url { get; set; }
    /// <summary>
    /// Extension container element for Url
    /// </summary>
    public Element _Url { get; set; }
    /// <summary>
    /// When multiple useContexts are specified, there is no expectation that all or any of the contexts apply.
    /// </summary>
    public List<UsageContext> UseContext { get; set; }
    /// <summary>
    /// There may be different concept map instances that have the same identifier but different versions.  The version can be appended to the url in a reference to allow a reference to a particular business version of the concept map with the format [url]|[version].
    /// </summary>
    public string Version { get; set; }
    /// <summary>
    /// Extension container element for Version
    /// </summary>
    public Element _Version { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR4B.Models.DomainResource)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Url))
      {
        writer.WriteString("url", (string)Url!);
      }

      if (_Url != null)
      {
        writer.WritePropertyName("_url");
        _Url.SerializeJson(writer, options);
      }

      if (Identifier != null)
      {
        writer.WritePropertyName("identifier");
        Identifier.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Version))
      {
        writer.WriteString("version", (string)Version!);
      }

      if (_Version != null)
      {
        writer.WritePropertyName("_version");
        _Version.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Name))
      {
        writer.WriteString("name", (string)Name!);
      }

      if (_Name != null)
      {
        writer.WritePropertyName("_name");
        _Name.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Title))
      {
        writer.WriteString("title", (string)Title!);
      }

      if (_Title != null)
      {
        writer.WritePropertyName("_title");
        _Title.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (Experimental != null)
      {
        writer.WriteBoolean("experimental", (bool)Experimental!);
      }

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Publisher))
      {
        writer.WriteString("publisher", (string)Publisher!);
      }

      if (_Publisher != null)
      {
        writer.WritePropertyName("_publisher");
        _Publisher.SerializeJson(writer, options);
      }

      if ((Contact != null) && (Contact.Count != 0))
      {
        writer.WritePropertyName("contact");
        writer.WriteStartArray();

        foreach (ContactDetail valContact in Contact)
        {
          valContact.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Description))
      {
        writer.WriteString("description", (string)Description!);
      }

      if (_Description != null)
      {
        writer.WritePropertyName("_description");
        _Description.SerializeJson(writer, options);
      }

      if ((UseContext != null) && (UseContext.Count != 0))
      {
        writer.WritePropertyName("useContext");
        writer.WriteStartArray();

        foreach (UsageContext valUseContext in UseContext)
        {
          valUseContext.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Jurisdiction != null) && (Jurisdiction.Count != 0))
      {
        writer.WritePropertyName("jurisdiction");
        writer.WriteStartArray();

        foreach (CodeableConcept valJurisdiction in Jurisdiction)
        {
          valJurisdiction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Purpose))
      {
        writer.WriteString("purpose", (string)Purpose!);
      }

      if (_Purpose != null)
      {
        writer.WritePropertyName("_purpose");
        _Purpose.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Copyright))
      {
        writer.WriteString("copyright", (string)Copyright!);
      }

      if (_Copyright != null)
      {
        writer.WritePropertyName("_copyright");
        _Copyright.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SourceUri))
      {
        writer.WriteString("sourceUri", (string)SourceUri!);
      }

      if (_SourceUri != null)
      {
        writer.WritePropertyName("_sourceUri");
        _SourceUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SourceCanonical))
      {
        writer.WriteString("sourceCanonical", (string)SourceCanonical!);
      }

      if (_SourceCanonical != null)
      {
        writer.WritePropertyName("_sourceCanonical");
        _SourceCanonical.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TargetUri))
      {
        writer.WriteString("targetUri", (string)TargetUri!);
      }

      if (_TargetUri != null)
      {
        writer.WritePropertyName("_targetUri");
        _TargetUri.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TargetCanonical))
      {
        writer.WriteString("targetCanonical", (string)TargetCanonical!);
      }

      if (_TargetCanonical != null)
      {
        writer.WritePropertyName("_targetCanonical");
        _TargetCanonical.SerializeJson(writer, options);
      }

      if ((Group != null) && (Group.Count != 0))
      {
        writer.WritePropertyName("group");
        writer.WriteStartArray();

        foreach (ConceptMapGroup valGroup in Group)
        {
          valGroup.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "contact":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Contact = new List<ContactDetail>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ContactDetail objContact = new fhirCsR4B.Models.ContactDetail();
            objContact.DeserializeJson(ref reader, options);
            Contact.Add(objContact);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Contact.Count == 0)
          {
            Contact = null;
          }

          break;

        case "copyright":
          Copyright = reader.GetString();
          break;

        case "_copyright":
          _Copyright = new fhirCsR4B.Models.Element();
          _Copyright.DeserializeJson(ref reader, options);
          break;

        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR4B.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "description":
          Description = reader.GetString();
          break;

        case "_description":
          _Description = new fhirCsR4B.Models.Element();
          _Description.DeserializeJson(ref reader, options);
          break;

        case "experimental":
          Experimental = reader.GetBoolean();
          break;

        case "group":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Group = new List<ConceptMapGroup>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.ConceptMapGroup objGroup = new fhirCsR4B.Models.ConceptMapGroup();
            objGroup.DeserializeJson(ref reader, options);
            Group.Add(objGroup);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Group.Count == 0)
          {
            Group = null;
          }

          break;

        case "identifier":
          Identifier = new fhirCsR4B.Models.Identifier();
          Identifier.DeserializeJson(ref reader, options);
          break;

        case "jurisdiction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Jurisdiction = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.CodeableConcept objJurisdiction = new fhirCsR4B.Models.CodeableConcept();
            objJurisdiction.DeserializeJson(ref reader, options);
            Jurisdiction.Add(objJurisdiction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Jurisdiction.Count == 0)
          {
            Jurisdiction = null;
          }

          break;

        case "name":
          Name = reader.GetString();
          break;

        case "_name":
          _Name = new fhirCsR4B.Models.Element();
          _Name.DeserializeJson(ref reader, options);
          break;

        case "publisher":
          Publisher = reader.GetString();
          break;

        case "_publisher":
          _Publisher = new fhirCsR4B.Models.Element();
          _Publisher.DeserializeJson(ref reader, options);
          break;

        case "purpose":
          Purpose = reader.GetString();
          break;

        case "_purpose":
          _Purpose = new fhirCsR4B.Models.Element();
          _Purpose.DeserializeJson(ref reader, options);
          break;

        case "sourceUri":
          SourceUri = reader.GetString();
          break;

        case "_sourceUri":
          _SourceUri = new fhirCsR4B.Models.Element();
          _SourceUri.DeserializeJson(ref reader, options);
          break;

        case "sourceCanonical":
          SourceCanonical = reader.GetString();
          break;

        case "_sourceCanonical":
          _SourceCanonical = new fhirCsR4B.Models.Element();
          _SourceCanonical.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR4B.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "targetUri":
          TargetUri = reader.GetString();
          break;

        case "_targetUri":
          _TargetUri = new fhirCsR4B.Models.Element();
          _TargetUri.DeserializeJson(ref reader, options);
          break;

        case "targetCanonical":
          TargetCanonical = reader.GetString();
          break;

        case "_targetCanonical":
          _TargetCanonical = new fhirCsR4B.Models.Element();
          _TargetCanonical.DeserializeJson(ref reader, options);
          break;

        case "title":
          Title = reader.GetString();
          break;

        case "_title":
          _Title = new fhirCsR4B.Models.Element();
          _Title.DeserializeJson(ref reader, options);
          break;

        case "url":
          Url = reader.GetString();
          break;

        case "_url":
          _Url = new fhirCsR4B.Models.Element();
          _Url.DeserializeJson(ref reader, options);
          break;

        case "useContext":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UseContext = new List<UsageContext>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR4B.Models.UsageContext objUseContext = new fhirCsR4B.Models.UsageContext();
            objUseContext.DeserializeJson(ref reader, options);
            UseContext.Add(objUseContext);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UseContext.Count == 0)
          {
            UseContext = null;
          }

          break;

        case "version":
          Version = reader.GetString();
          break;

        case "_version":
          _Version = new fhirCsR4B.Models.Element();
          _Version.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR4B.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the ConceptMap.status field
  /// </summary>
  public static class ConceptMapStatusCodes {
    public const string DRAFT = "draft";
    public const string ACTIVE = "active";
    public const string RETIRED = "retired";
    public const string UNKNOWN = "unknown";
  }
}
